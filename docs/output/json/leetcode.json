{"QuestionInfo": [{"question": {"content": "<pre><code>def singleNumber(self, nums):\n    ab = m = reduce(operator.xor, nums)  # a ^ b\n    m &amp;= -m  # bit hack, isolate the rightmost 1-bit\n    a = reduce(operator.xor, (n for n in nums if n &amp; m))\n    return [a, ab ^ a]  # if a &amp; m then not b &amp; m       \n</code></pre><code>def singleNumber(self, nums):\n    ab = m = reduce(operator.xor, nums)  # a ^ b\n    m &amp;= -m  # bit hack, isolate the rightmost 1-bit\n    a = reduce(operator.xor, (n for n in nums if n &amp; m))\n    return [a, ab ^ a]  # if a &amp; m then not b &amp; m       \n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Single Number III", "author_score": "20,650", "time": "2015-08-17T11:50:36+0000"}}, "answers": [], "title": "Python Solution"}, {"question": {"content": "<pre><code>def binaryTreePaths(self, root):\n    if root is None:\n        return []\n    answer, stack = [], [[root]]\n    while stack:\n        path = stack.pop()\n        node = path.pop()\n        path.append(str(node.val))\n        if node.left is node.right is None:\n            answer.append('-&gt;'.join(path))\n        node.left and stack.append(path + [node.left])\n        node.right and stack.append(path + [node.right])\n    return answer\n</code></pre><code>def binaryTreePaths(self, root):\n    if root is None:\n        return []\n    answer, stack = [], [[root]]\n    while stack:\n        path = stack.pop()\n        node = path.pop()\n        path.append(str(node.val))\n        if node.left is node.right is None:\n            answer.append('-&gt;'.join(path))\n        node.left and stack.append(path + [node.left])\n        node.right and stack.append(path + [node.right])\n    return answer\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Binary Tree Paths", "author_score": "20,650", "time": "2015-08-16T05:57:06+0000"}}, "answers": [], "title": "Python Iterative Solution"}, {"question": {"content": "<pre><code>class Solution:\n\ndef isAnagram(self, s, t):\n    return collections.Counter(s) == collections.Counter(t)\n</code></pre><code>class Solution:\n\ndef isAnagram(self, s, t):\n    return collections.Counter(s) == collections.Counter(t)\n</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "tusizi", "catagory": "Valid Anagram", "author_score": "20,650", "time": "2015-08-01T13:09:24+0000"}}, "answers": [], "title": "Python one-liner with Counter"}, {"question": {"content": "<pre><code>class Solution:\n\ndef diffWaysToCompute(self, expression):\n    if expression.isdigit():\n        return [int(expression)]\n    expression = re.split(r'([+\\-*])', expression)\n    stack, visited, ways = [expression], set(), set()\n    while stack:\n        exp = stack.pop()\n        for i in range(len(exp)):\n            if exp[i] in '+-*':\n                new_exp = exp[:]\n                new_exp[i - 1:i + 2] = '({})'.format(\n                    ''.join(exp[i - 1:i + 2])),\n                s = ''.join(new_exp)\n                if len(new_exp) == 1:\n                    ways.add(s)\n                elif s not in visited:\n                    visited.add(s)\n                    stack.append(new_exp)\n    return [self._calculate(i) for i in ways]\n\ndef _calculate(self, expression):\n    op = {'+': operator.add, '-': operator.sub, '*': operator.mul}\n    stack = []\n    for i in expression:\n        if i.isdigit() and stack[-1].isdigit():\n            stack[-1] += i\n        elif i == ')':\n            second, o, first, _ = [stack.pop() for _ in range(4)]\n            stack.append(str(op[o](int(first), int(second))))\n        else:\n            stack.append(i)\n    return int(stack[0])\n</code></pre><code>class Solution:\n\ndef diffWaysToCompute(self, expression):\n    if expression.isdigit():\n        return [int(expression)]\n    expression = re.split(r'([+\\-*])', expression)\n    stack, visited, ways = [expression], set(), set()\n    while stack:\n        exp = stack.pop()\n        for i in range(len(exp)):\n            if exp[i] in '+-*':\n                new_exp = exp[:]\n                new_exp[i - 1:i + 2] = '({})'.format(\n                    ''.join(exp[i - 1:i + 2])),\n                s = ''.join(new_exp)\n                if len(new_exp) == 1:\n                    ways.add(s)\n                elif s not in visited:\n                    visited.add(s)\n                    stack.append(new_exp)\n    return [self._calculate(i) for i in ways]\n\ndef _calculate(self, expression):\n    op = {'+': operator.add, '-': operator.sub, '*': operator.mul}\n    stack = []\n    for i in expression:\n        if i.isdigit() and stack[-1].isdigit():\n            stack[-1] += i\n        elif i == ')':\n            second, o, first, _ = [stack.pop() for _ in range(4)]\n            stack.append(str(op[o](int(first), int(second))))\n        else:\n            stack.append(i)\n    return int(stack[0])\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Different Ways to Add Parentheses", "author_score": "20,650", "time": "2015-07-27T12:38:01+0000"}}, "answers": [], "title": "Python solution, slow but simple to get the idea"}, {"question": {"content": "<pre><code>class Solution:\n\ndef maxSlidingWindow(self, nums, k):\n    heap, counter, answer = [], collections.Counter(), []\n    for idx, n in enumerate(nums):\n        heapq.heappush(heap, -n)\n        counter[n] += 1\n        if idx &gt;= k - 1:\n            while counter[-heap[0]] == 0:\n                heapq.heappop(heap)\n            answer.append(-heap[0])\n            counter[nums[idx - k + 1]] -= 1\n    return answer\n</code></pre><code>class Solution:\n\ndef maxSlidingWindow(self, nums, k):\n    heap, counter, answer = [], collections.Counter(), []\n    for idx, n in enumerate(nums):\n        heapq.heappush(heap, -n)\n        counter[n] += 1\n        if idx &gt;= k - 1:\n            while counter[-heap[0]] == 0:\n                heapq.heappop(heap)\n            answer.append(-heap[0])\n            counter[nums[idx - k + 1]] -= 1\n    return answer\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Sliding Window Maximum", "author_score": "20,650", "time": "2015-07-19T05:21:57+0000"}}, "answers": [{"content": "<p>I think O(n log n), even for k=2. Consider a case where <code>nums</code> alternates between <code>2**30</code> and random smaller numbers, followed by a few <code>-1</code> elements:</p><code>nums</code><code>2**30</code><code>-1</code><pre><code>n = 10000\nk = 2\nnums = [random.randrange(2**30) if i%2 else 2**30\n        for i in range(n)]\nnums += [-1] * 3\nprint Solution().maxSlidingWindow(nums, k)\n</code></pre><code>n = 10000\nk = 2\nnums = [random.randrange(2**30) if i%2 else 2**30\n        for i in range(n)]\nnums += [-1] * 3\nprint Solution().maxSlidingWindow(nums, k)\n</code><p>The window always contains a <code>2**30</code> and that's the overall largest number, so it blocks any popping until the very end, where everything but the three <code>-1</code> elements will be popped. So you build up a heap with ~n elements, and then popping them all takes O(n log n), I think.</p><code>2**30</code><code>-1</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "StefanPochmann", "author_score": "75,020", "time": "2015-07-19T20:02:46+0000"}, "best_answer": true}], "title": "What is the time complex for this solution with python heapq ?"}, {"question": {"content": "<pre><code>class Solution:\n\ndef lowestCommonAncestor(self, root, p, q):\n    p = self._dfs(root, p)\n    q = self._dfs(root, q)\n    answer = root\n    while p and q and p[-1] is q.pop():\n        answer = p.pop()\n    return answer\n\ndef _dfs(self, root, n):\n    parents = dict()\n    stack = [root]\n    while stack:\n        node = stack.pop()\n        if node is None:\n            continue\n        if node is n:\n            break\n        stack.append(node.left)\n        stack.append(node.right)\n        parents[node.left] = node\n        parents[node.right] = node\n\n    answer = [n]\n    while answer[-1] != root:\n        answer.append(parents[answer[-1]])\n    return answer\n</code></pre><code>class Solution:\n\ndef lowestCommonAncestor(self, root, p, q):\n    p = self._dfs(root, p)\n    q = self._dfs(root, q)\n    answer = root\n    while p and q and p[-1] is q.pop():\n        answer = p.pop()\n    return answer\n\ndef _dfs(self, root, n):\n    parents = dict()\n    stack = [root]\n    while stack:\n        node = stack.pop()\n        if node is None:\n            continue\n        if node is n:\n            break\n        stack.append(node.left)\n        stack.append(node.right)\n        parents[node.left] = node\n        parents[node.right] = node\n\n    answer = [n]\n    while answer[-1] != root:\n        answer.append(parents[answer[-1]])\n    return answer\n</code><p>common recursion</p><pre><code>class Solution:\n\ndef lowestCommonAncestor(self, root, p, q):\n    if root in (None, p, q):\n        return root\n    left = self.lowestCommonAncestor(root.left, p, q)\n    right = self.lowestCommonAncestor(root.right, p, q)\n    if left and right:\n        return root\n    return left or right\n</code></pre><code>class Solution:\n\ndef lowestCommonAncestor(self, root, p, q):\n    if root in (None, p, q):\n        return root\n    left = self.lowestCommonAncestor(root.left, p, q)\n    right = self.lowestCommonAncestor(root.right, p, q)\n    if left and right:\n        return root\n    return left or right\n</code>", "votes": {"down": "0", "up": "2"}, "meta": {"author": "tusizi", "catagory": "Lowest Common Ancestor of a Binary Tree", "author_score": "20,650", "time": "2015-07-13T05:59:15+0000"}}, "answers": [{"content": "<p>I like your idea. When I tried it myself, I found its running time is ~360 ms</p><p>And I found the following optimization points.</p><ol>\n<li>Do the dfs just once, searching for p and q at the same time. Return dictionary of parents instead of path</li>\n<li>If the other node is met when constructing path to root, return the other node</li>\n</ol><li>Do the dfs just once, searching for p and q at the same time. Return dictionary of parents instead of path</li><li>If the other node is met when constructing path to root, return the other node</li><p>Below is the code. Much longer but running time is reduced to below 240 ms</p><pre><code>class Solution:\n    # @param {TreeNode} root\n    # @param {TreeNode} p\n    # @param {TreeNode} q\n    # @return {TreeNode}\n    def lowestCommonAncestor(self, root, p, q):\n        def _retrievePath(parents, p, q):\n            path = [p]\n            try:\n                while path[-1] is not q:\n                    path.append(parents[path[-1]])\n                return (q, [])\n            except KeyError:\n                # reaches root, who has no parent\n                return (None, path)\n\n        def _searchParents(root, p, q):\n            parents, stack = dict(), [root]\n            pFound = qFound = False\n            while stack:\n                node = stack.pop()\n                # if both p and q are found, break\n                if node is p:\n                    if qFound:\n                        break\n                    pFound = True\n                elif node is q:\n                    if pFound:\n                        break\n                    qFound = True\n                # push left and right child to stack, set parents\n                if node.right:\n                    stack.append(node.right)\n                    parents[node.right] = node\n                if node.left:\n                    stack.append(node.left)\n                    parents[node.left] = node\n            return parents\n\n        parents = _searchParents(root, p, q)\n        (node, path_p) = _retrievePath(parents, p, q)\n        if node:\n            return node\n        (node, path_q) = _retrievePath(parents, q, p)\n        if node:\n            return node\n\n        ancestor = root\n        while path_p and path_q and path_p[-1] is path_q.pop():\n            ancestor = path_p.pop()\n        return ancestor\n</code></pre><code>class Solution:\n    # @param {TreeNode} root\n    # @param {TreeNode} p\n    # @param {TreeNode} q\n    # @return {TreeNode}\n    def lowestCommonAncestor(self, root, p, q):\n        def _retrievePath(parents, p, q):\n            path = [p]\n            try:\n                while path[-1] is not q:\n                    path.append(parents[path[-1]])\n                return (q, [])\n            except KeyError:\n                # reaches root, who has no parent\n                return (None, path)\n\n        def _searchParents(root, p, q):\n            parents, stack = dict(), [root]\n            pFound = qFound = False\n            while stack:\n                node = stack.pop()\n                # if both p and q are found, break\n                if node is p:\n                    if qFound:\n                        break\n                    pFound = True\n                elif node is q:\n                    if pFound:\n                        break\n                    qFound = True\n                # push left and right child to stack, set parents\n                if node.right:\n                    stack.append(node.right)\n                    parents[node.right] = node\n                if node.left:\n                    stack.append(node.left)\n                    parents[node.left] = node\n            return parents\n\n        parents = _searchParents(root, p, q)\n        (node, path_p) = _retrievePath(parents, p, q)\n        if node:\n            return node\n        (node, path_q) = _retrievePath(parents, q, p)\n        if node:\n            return node\n\n        ancestor = root\n        while path_p and path_q and path_p[-1] is path_q.pop():\n            ancestor = path_p.pop()\n        return ancestor\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "dasheng2", "author_score": "3,750", "time": "2015-07-29T02:07:19+0000"}}], "title": "Python dfs + backtrack solution, no recursion"}, {"question": {"content": "<pre><code>class Solution:\n\ndef lowestCommonAncestor(self, root, p, q):\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n</code></pre><code>class Solution:\n\ndef lowestCommonAncestor(self, root, p, q):\n    while root:\n        if root.val &gt; p.val and root.val &gt; q.val:\n            root = root.left\n        elif root.val &lt; p.val and root.val &lt; q.val:\n            root = root.right\n        else:\n            return root\n</code>", "votes": {"down": "0", "up": "4"}, "meta": {"author": "tusizi", "catagory": "Lowest Common Ancestor of a Binary Search Tree", "author_score": "20,650", "time": "2015-07-11T09:41:45+0000"}}, "answers": [{"content": "<p>A bit simpler:</p><pre><code>def lowestCommonAncestor(self, root, p, q):\n    while root:\n        if max(p.val, q.val) &lt; root.val:\n            root = root.left\n        elif min(p.val, q.val) &gt; root.val:\n            root = root.right\n        else:\n            return root\n    return None\n</code></pre><code>def lowestCommonAncestor(self, root, p, q):\n    while root:\n        if max(p.val, q.val) &lt; root.val:\n            root = root.left\n        elif min(p.val, q.val) &gt; root.val:\n            root = root.right\n        else:\n            return root\n    return None\n</code>", "votes": {"down": "0", "up": "2"}, "meta": {"author": "Bluryi", "author_score": "420", "time": "2015-07-23T06:13:01+0000"}}], "title": "Python Iterative Solution"}, {"question": {"content": "<pre><code>class Solution:\n# @param {integer} n\n# @return {boolean}\ndef isPowerOfTwo(self, n):\n    return any(n == 2 ** i for i in range(32))\n</code></pre><code>class Solution:\n# @param {integer} n\n# @return {boolean}\ndef isPowerOfTwo(self, n):\n    return any(n == 2 ** i for i in range(32))\n</code><p>or </p><pre><code>class Solution:\n# @param {integer} n\n# @return {boolean}\ndef isPowerOfTwo(self, n):\n    return any(n == 1 &lt;&lt; i for i in range(32))\n</code></pre><code>class Solution:\n# @param {integer} n\n# @return {boolean}\ndef isPowerOfTwo(self, n):\n    return any(n == 1 &lt;&lt; i for i in range(32))\n</code><p>or bit hack</p><pre><code>class Solution:\n# @param {integer} n\n# @return {boolean}\ndef isPowerOfTwo(self, n):\n    return n &gt; 0 and n &amp; (n - 1) == 0\n</code></pre><code>class Solution:\n# @param {integer} n\n# @return {boolean}\ndef isPowerOfTwo(self, n):\n    return n &gt; 0 and n &amp; (n - 1) == 0\n</code>", "votes": {"down": "0", "up": "2"}, "meta": {"author": "tusizi", "catagory": "Power of Two", "author_score": "20,650", "time": "2015-07-06T03:53:05+0000"}}, "answers": [], "title": "Python one-line"}, {"question": {"content": "<pre><code>class Solution:\n# @param {integer[]} nums\n# @return {integer[]}\ndef majorityElement(self, nums):\n    n1, n2 = 0, 1\n    c1 = c2 = 0\n    for n in nums:\n        if n == n1:\n            c1 += 1\n        elif n == n2:\n            c2 += 1\n        else:\n            c1 -= 1\n            c2 -= 1\n        if c1 &lt; 0:\n            n1 = n\n            c1 = 1\n        elif c2 &lt; 0 and n1 != n:\n            n2 = n\n            c2 = 1\n    return [n for n in (n1, n2) if nums.count(n) &gt; len(nums) // 3]\n</code></pre><code>class Solution:\n# @param {integer[]} nums\n# @return {integer[]}\ndef majorityElement(self, nums):\n    n1, n2 = 0, 1\n    c1 = c2 = 0\n    for n in nums:\n        if n == n1:\n            c1 += 1\n        elif n == n2:\n            c2 += 1\n        else:\n            c1 -= 1\n            c2 -= 1\n        if c1 &lt; 0:\n            n1 = n\n            c1 = 1\n        elif c2 &lt; 0 and n1 != n:\n            n2 = n\n            c2 = 1\n    return [n for n in (n1, n2) if nums.count(n) &gt; len(nums) // 3]\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Majority Element II", "author_score": "20,650", "time": "2015-06-29T07:32:39+0000"}}, "answers": [], "title": "Python AC Solution"}, {"question": {"content": "<pre><code>class Solution:\n# @param {integer[]} nums\n# @return {string[]}\ndef summaryRanges(self, nums):\n    ans = []\n    start = 0\n    for n in range(1, len(nums)):\n        if nums[n] != nums[n - 1] + 1:\n            ans.append('{}-&gt;{}'.format(nums[start], nums[n - 1]))\n            start = n\n    nums and ans.append('{}-&gt;{}'.format(nums[start], nums[-1]))\n    return [i.replace('-&gt;' + i[:len(i) // 2 - 1], '') for i in ans]\n</code></pre><code>class Solution:\n# @param {integer[]} nums\n# @return {string[]}\ndef summaryRanges(self, nums):\n    ans = []\n    start = 0\n    for n in range(1, len(nums)):\n        if nums[n] != nums[n - 1] + 1:\n            ans.append('{}-&gt;{}'.format(nums[start], nums[n - 1]))\n            start = n\n    nums and ans.append('{}-&gt;{}'.format(nums[start], nums[-1]))\n    return [i.replace('-&gt;' + i[:len(i) // 2 - 1], '') for i in ans]\n</code><p>itertools.groupby</p><pre><code>class Solution:\n# @param {integer[]} nums\n# @return {string[]}\ndef summaryRanges(self, nums):\n    f = lambda x: x[0] - x[1]\n    groups = [list(g) for _, g in itertools.groupby(enumerate(nums), f)]\n    groups = ['{}-&gt;{}'.format(g[0][1], g[-1][1])\n              if len(g) &gt; 1 else str(g[0][1]) for g in groups]\n    return groups\n</code></pre><code>class Solution:\n# @param {integer[]} nums\n# @return {string[]}\ndef summaryRanges(self, nums):\n    f = lambda x: x[0] - x[1]\n    groups = [list(g) for _, g in itertools.groupby(enumerate(nums), f)]\n    groups = ['{}-&gt;{}'.format(g[0][1], g[-1][1])\n              if len(g) &gt; 1 else str(g[0][1]) for g in groups]\n    return groups\n</code>", "votes": {"down": "0", "up": "2"}, "meta": {"author": "tusizi", "catagory": "Summary Ranges", "author_score": "20,650", "time": "2015-06-26T14:30:03+0000"}}, "answers": [], "title": "Python straight forward and groupby solution"}, {"question": {"content": "<pre><code>class Solution:\n# @param {string} s\n# @return {integer}\ndef calculate(self, s):\n    s = re.sub(r'\\d+', ' \\g&lt;0&gt; ', s)\n    op = {'+': operator.add, '-': operator.sub,\n          '*': operator.mul, '/': operator.floordiv}\n    expression = s.split()\n    total = d = idx = 0\n    func = op['+']\n    while idx &lt; len(expression):\n        e = expression[idx]\n        if e in '+-':\n            total = func(total, d)\n            func = op[e]\n        elif e in '*/':\n            idx += 1\n            d = op[e](d, int(expression[idx]))\n        else:\n            d = int(e)\n        idx += 1\n    return func(total, d)\n</code></pre><code>class Solution:\n# @param {string} s\n# @return {integer}\ndef calculate(self, s):\n    s = re.sub(r'\\d+', ' \\g&lt;0&gt; ', s)\n    op = {'+': operator.add, '-': operator.sub,\n          '*': operator.mul, '/': operator.floordiv}\n    expression = s.split()\n    total = d = idx = 0\n    func = op['+']\n    while idx &lt; len(expression):\n        e = expression[idx]\n        if e in '+-':\n            total = func(total, d)\n            func = op[e]\n        elif e in '*/':\n            idx += 1\n            d = op[e](d, int(expression[idx]))\n        else:\n            d = int(e)\n        idx += 1\n    return func(total, d)\n</code>", "votes": {"down": "0", "up": "3"}, "meta": {"author": "tusizi", "catagory": "Basic Calculator II", "author_score": "20,650", "time": "2015-06-22T13:30:15+0000"}}, "answers": [], "title": "AC Python solution, Use Re to get the expression"}, {"question": {"content": "<pre><code>class Solution:\ndef invertTree(self, root):\n    stack = [root]\n    while stack:\n        node = stack.pop()\n        if node is None:\n            continue\n        node.left, node.right = node.right, node.left\n        stack.append(node.left)\n        stack.append(node.right)\n    return root\n</code></pre><code>class Solution:\ndef invertTree(self, root):\n    stack = [root]\n    while stack:\n        node = stack.pop()\n        if node is None:\n            continue\n        node.left, node.right = node.right, node.left\n        stack.append(node.left)\n        stack.append(node.right)\n    return root\n</code><p>Recursion</p><pre><code>class Solution:\ndef invertTree(self, root):\n    if not root:\n        return\n    root.left, root.right = root.right, root.left\n    self.invertTree(root.left)\n    self.invertTree(root.right)\n    return root\n</code></pre><code>class Solution:\ndef invertTree(self, root):\n    if not root:\n        return\n    root.left, root.right = root.right, root.left\n    self.invertTree(root.left)\n    self.invertTree(root.right)\n    return root\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Invert Binary Tree", "author_score": "20,650", "time": "2015-06-12T09:19:32+0000"}, "comments": [{"content": "<p>I noticed you always include that <code>class Solution:</code> line but never indent the body. That makes every single one of your solutions have an IndentationError. Why do you do that?</p><code>class Solution:</code>", "votes": null, "meta": {"author": "StefanPochmann", "author_score": "75,020", "time": "2015-07-11T17:12:31+0000"}}]}, "answers": [], "title": "Two AC Python Solution"}, {"question": {"content": "<pre><code>class Solution:\ndef calculate(self, s):\n    s = '+(+' + s + ')'\n    s = s.replace('+-', '-').replace('++', '+') # for the corner case '-5', '+5'\n    stack = []\n    for i in s:\n        if i == ')':\n            total = 0\n            while stack[-1] != '(':\n                total += int(stack.pop())\n            stack.pop()\n            sign = 1 if stack.pop() == '+' else -1\n            stack.append(sign * total)\n        elif i.isdigit() and stack[-1][-1] in '+-0123456789':\n            stack[-1] += i\n        elif i != ' ':\n            stack.append(i)\n    return stack[0]\n</code></pre><code>class Solution:\ndef calculate(self, s):\n    s = '+(+' + s + ')'\n    s = s.replace('+-', '-').replace('++', '+') # for the corner case '-5', '+5'\n    stack = []\n    for i in s:\n        if i == ')':\n            total = 0\n            while stack[-1] != '(':\n                total += int(stack.pop())\n            stack.pop()\n            sign = 1 if stack.pop() == '+' else -1\n            stack.append(sign * total)\n        elif i.isdigit() and stack[-1][-1] in '+-0123456789':\n            stack[-1] += i\n        elif i != ' ':\n            stack.append(i)\n    return stack[0]\n</code>", "votes": {"down": "0", "up": "5"}, "meta": {"author": "tusizi", "catagory": "Basic Calculator", "author_score": "20,650", "time": "2015-06-11T07:33:18+0000"}}, "answers": [{"content": "<p>Brilliant solution, but there is a corner case that you may have missed. Try '-5'</p>", "votes": {"down": "0", "up": "2"}, "meta": {"author": "xiangzhou.chen.5", "author_score": "1,000", "time": "2015-06-16T01:55:27+0000"}, "best_answer": true, "comments": [{"content": "<p>You are right, I add s = s.replace('+-', '-').replace('++', '+') for that corner case</p>", "votes": null, "meta": {"author": "tusizi", "author_score": "20,650", "time": "2015-06-17T03:40:13+0000"}}]}, {"content": "<p>So glad I found this. Orders of magnitude faster than my solution. But the code does not accommodate for cases in which multiple opening parentheses are adjacent to one another other: '((1 + 2))' or '((1 + 2) + 3 + 4) + 5'. Granted the adjacent opening parentheses do not affect the computational result, they still make for a valid expression and may come in handy if we want to extend the code to also handle multiplications (e.g. '((1 + 2)3 + 4)5'). </p><p>An additional case in the for loop solves the issue:</p><pre><code>            elif i == '(' and stack[-1] == '(':\n                stack.append('+')\n                stack.append(i)\n</code></pre><code>            elif i == '(' and stack[-1] == '(':\n                stack.append('+')\n                stack.append(i)\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "jujuwoman", "author_score": "110", "time": "2015-07-05T01:23:40+0000"}}], "title": "AC Python Solution"}, {"question": {"content": "<pre><code>class Solution:\ndef computeArea(self, a, b, c, d, e, f, g, h):\n    width = self._compute(a, c, e, g)\n    height = self._compute(b, d, f, h)\n    return (c - a) * (d - b) + (g - e) * (h - f) - width * height\n\ndef _compute(self, a, b, c, d):\n    if a &gt; c:\n        a, b, c, d = c, d, a, b\n    if c &lt; b &lt; d:\n        return b - c\n    if d &lt;= b:\n        return d - c\n    return 0\n</code></pre><code>class Solution:\ndef computeArea(self, a, b, c, d, e, f, g, h):\n    width = self._compute(a, c, e, g)\n    height = self._compute(b, d, f, h)\n    return (c - a) * (d - b) + (g - e) * (h - f) - width * height\n\ndef _compute(self, a, b, c, d):\n    if a &gt; c:\n        a, b, c, d = c, d, a, b\n    if c &lt; b &lt; d:\n        return b - c\n    if d &lt;= b:\n        return d - c\n    return 0\n</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "tusizi", "catagory": "Rectangle Area", "author_score": "20,650", "time": "2015-06-11T05:47:29+0000"}}, "answers": [], "title": "AC Python Solution"}, {"question": {"content": "<pre><code>class Solution:\n\ndef containsNearbyAlmostDuplicate(self, nums, k, t):\n    if k &lt; 1 or t &lt; 0:\n        return False\n    dic = collections.OrderedDict()\n    for n in nums:\n        key = n if not t else n // t\n        for m in (dic.get(key - 1), dic.get(key), dic.get(key + 1)):\n            if m is not None and abs(n - m) &lt;= t:\n                return True\n        if len(dic) == k:\n            dic.popitem(False)\n        dic[key] = n\n    return False\n</code></pre><code>class Solution:\n\ndef containsNearbyAlmostDuplicate(self, nums, k, t):\n    if k &lt; 1 or t &lt; 0:\n        return False\n    dic = collections.OrderedDict()\n    for n in nums:\n        key = n if not t else n // t\n        for m in (dic.get(key - 1), dic.get(key), dic.get(key + 1)):\n            if m is not None and abs(n - m) &lt;= t:\n                return True\n        if len(dic) == k:\n            dic.popitem(False)\n        dic[key] = n\n    return False\n</code>", "votes": {"down": "0", "up": "11"}, "meta": {"author": "tusizi", "catagory": "Contains Duplicate III", "author_score": "20,650", "time": "2015-06-01T08:41:48+0000"}, "comments": [{"content": "<p>@tusizi, can you explain a little bit about n//t and (dic.get(key - 1), dic.get(key), dic.get(key + 1)) here? I tried to figure them out but difficult, thanks.</p>", "votes": null, "meta": {"author": "caikehe", "author_score": "8,580", "time": "2015-08-23T17:31:57+0000"}}]}, "answers": [{"content": "<p>Very helpful, use OrderedDict to remember the index and n//t to shrink the interval to -1, 0, 1.</p>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "judanju", "author_score": "160", "time": "2015-06-01T16:42:55+0000"}}], "title": "Python OrderedDict"}, {"question": {"content": "<pre><code>class Solution:\n# @param {integer} k\n# @param {integer} n\n# @return {integer[][]}\ndef combinationSum3(self, k, n):\n    result = [[0]]\n    for i in reversed(range(k)):\n        level = []\n        for r in result:\n            total = r.pop()\n            start = r[-1] if r else 0\n            for j in range(start + 1, 10):\n                res = r + [j]\n                if total + j * (i + 1) &gt; n:\n                    break\n                elif i == 0:\n                    if total + j == n:\n                        level.append(res)\n                else:\n                    res.append(total + j)\n                    level.append(res)\n        result = level\n    return result\n</code></pre><code>class Solution:\n# @param {integer} k\n# @param {integer} n\n# @return {integer[][]}\ndef combinationSum3(self, k, n):\n    result = [[0]]\n    for i in reversed(range(k)):\n        level = []\n        for r in result:\n            total = r.pop()\n            start = r[-1] if r else 0\n            for j in range(start + 1, 10):\n                res = r + [j]\n                if total + j * (i + 1) &gt; n:\n                    break\n                elif i == 0:\n                    if total + j == n:\n                        level.append(res)\n                else:\n                    res.append(total + j)\n                    level.append(res)\n        result = level\n    return result\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Combination Sum III", "author_score": "20,650", "time": "2015-05-26T14:36:04+0000"}}, "answers": [], "title": "Python 40ms iterative solution"}, {"question": {"content": "<pre><code>class Solution:\n# @param {integer[]} nums\n# @param {integer} k\n# @return {integer}\ndef findKthLargest(self, nums, k):\n    h = []\n    for n in nums:\n        if len(h) &lt; k:\n            heapq.heappush(h, n)\n        else:\n            heapq.heappushpop(h, n)\n    return h[0]\n</code></pre><code>class Solution:\n# @param {integer[]} nums\n# @param {integer} k\n# @return {integer}\ndef findKthLargest(self, nums, k):\n    h = []\n    for n in nums:\n        if len(h) &lt; k:\n            heapq.heappush(h, n)\n        else:\n            heapq.heappushpop(h, n)\n    return h[0]\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Kth Largest Element in an Array", "author_score": "20,650", "time": "2015-05-26T11:23:11+0000"}}, "answers": [{"content": "<p>Sorry, I didn't get it.</p><p>Does this code return the minimum element?</p><p>I think the heapq maintain the min heap, right?</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "autekwing", "author_score": "710", "time": "2015-06-22T00:24:56+0000"}, "comments": [{"content": "<p>Yes, it's a min heap. So it always pops its smallest element. So in the end, since it <em>popped</em> all the <em>small</em> elements, it <em>contains</em> the k <em>largest</em> elements. And the smallest of those is the k-th largest element.</p><em>popped</em><em>small</em><em>contains</em><em>largest</em>", "votes": null, "meta": {"author": "StefanPochmann", "author_score": "75,020", "time": "2015-06-22T00:41:30+0000"}}]}], "title": "Python heapq, O(n lg k)"}, {"question": {"content": "<pre><code>class Node:\ndef __init__(self, k, v):\n    self.key = k\n    self.val = v\n    self.prev = None\n    self.next = None\n\nclass LRUCache:\ndef __init__(self, capacity):\n    self.capacity = capacity\n    self.dic = dict()\n    self.head = Node(0, 0)\n    self.tail = Node(0, 0)\n    self.head.next = self.tail\n    self.tail.prev = self.head\n\ndef get(self, key):\n    if key in self.dic:\n        n = self.dic[key]\n        self._remove(n)\n        self._add(n)\n        return n.val\n    return -1\n\ndef set(self, key, value):\n    if key in self.dic:\n        self._remove(self.dic[key])\n    n = Node(key, value)\n    self._add(n)\n    self.dic[key] = n\n    if len(self.dic) &gt; self.capacity:\n        n = self.head.next\n        self._remove(n)\n        del self.dic[n.key]\n\ndef _remove(self, node):\n    p = node.prev\n    n = node.next\n    p.next = n\n    n.prev = p\n\ndef _add(self, node):\n    p = self.tail.prev\n    p.next = node\n    self.tail.prev = node\n    node.prev = p\n    node.next = self.tail\n</code></pre><code>class Node:\ndef __init__(self, k, v):\n    self.key = k\n    self.val = v\n    self.prev = None\n    self.next = None\n\nclass LRUCache:\ndef __init__(self, capacity):\n    self.capacity = capacity\n    self.dic = dict()\n    self.head = Node(0, 0)\n    self.tail = Node(0, 0)\n    self.head.next = self.tail\n    self.tail.prev = self.head\n\ndef get(self, key):\n    if key in self.dic:\n        n = self.dic[key]\n        self._remove(n)\n        self._add(n)\n        return n.val\n    return -1\n\ndef set(self, key, value):\n    if key in self.dic:\n        self._remove(self.dic[key])\n    n = Node(key, value)\n    self._add(n)\n    self.dic[key] = n\n    if len(self.dic) &gt; self.capacity:\n        n = self.head.next\n        self._remove(n)\n        del self.dic[n.key]\n\ndef _remove(self, node):\n    p = node.prev\n    n = node.next\n    p.next = n\n    n.prev = p\n\ndef _add(self, node):\n    p = self.tail.prev\n    p.next = node\n    self.tail.prev = node\n    node.prev = p\n    node.next = self.tail\n</code>", "votes": {"down": "0", "up": "2"}, "meta": {"author": "tusizi", "catagory": "LRU Cache", "author_score": "20,650", "time": "2015-05-23T08:52:07+0000"}}, "answers": [], "title": "Python Dict + Double LinkedList"}, {"question": {"content": "<pre><code>public void connect(TreeLinkNode root) {\n    TreeLinkNode queue = root;\n    while (queue != null) {\n        TreeLinkNode level = new TreeLinkNode(0);\n        TreeLinkNode current = level;\n        while (queue != null) {\n            if (queue.left != null) {\n                current.next = queue.left;\n                current = current.next;\n            }\n            if (queue.right != null) {\n                current.next = queue.right;\n                current = current.next;\n            }\n            queue = queue.next;\n        }\n        queue = level.next;\n    }\n}\n</code></pre><code>public void connect(TreeLinkNode root) {\n    TreeLinkNode queue = root;\n    while (queue != null) {\n        TreeLinkNode level = new TreeLinkNode(0);\n        TreeLinkNode current = level;\n        while (queue != null) {\n            if (queue.left != null) {\n                current.next = queue.left;\n                current = current.next;\n            }\n            if (queue.right != null) {\n                current.next = queue.right;\n                current = current.next;\n            }\n            queue = queue.next;\n        }\n        queue = level.next;\n    }\n}\n</code>", "votes": {"down": "0", "up": "3"}, "meta": {"author": "tusizi", "catagory": "Populating Next Right Pointers in Each Node II", "author_score": "20,650", "time": "2015-05-21T04:03:54+0000"}}, "answers": [], "title": "Short Java BFS Solution"}, {"question": {"content": "<pre><code>class Solution:\n# @param {integer[]} nums\n# @return {integer}\ndef rob(self, nums):\n    if not nums:\n        return 0\n    return max(self._rob(nums[1:]), nums[0] + self._rob(nums[2:-1]))\n\ndef _rob(self, nums):\n    prev_no = prev_yes = 0\n    for n in nums:\n        temp = prev_no\n        prev_no = max(prev_no, prev_yes)\n        prev_yes = temp + n\n    return max(prev_no, prev_yes)\n</code></pre><code>class Solution:\n# @param {integer[]} nums\n# @return {integer}\ndef rob(self, nums):\n    if not nums:\n        return 0\n    return max(self._rob(nums[1:]), nums[0] + self._rob(nums[2:-1]))\n\ndef _rob(self, nums):\n    prev_no = prev_yes = 0\n    for n in nums:\n        temp = prev_no\n        prev_no = max(prev_no, prev_yes)\n        prev_yes = temp + n\n    return max(prev_no, prev_yes)\n</code><p>There are two cases,</p><p>if we do not rob house[0], we can rob nums[1:]</p><p>else we can rob nums[2:-1]</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "House Robber II", "author_score": "20,650", "time": "2015-05-20T07:35:22+0000"}}, "answers": [{"content": "<p>Same as my thought, but I cannot understand why you define a sub-function? Is it faster?</p><p>BTW my code is like this(40ms):</p><pre><code>class Solution:\n# @param {integer[]} nums\n# @return {integer}\ndef rob(self, nums):\n    if not nums:\n        return 0\n\n    if len(nums) == 1:\n        return nums[0]\n\n    if len(nums) == 2:\n        return max(nums[0], nums[1])\n\n    dp = {}\n    dpw0 = {}\n\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n    dpw0[0], dpw0[1] = 0, nums[1]\n\n\n    for i in range(2, len(nums) - 1):\n        dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\n        dpw0[i] = max(dpw0[i - 2] + nums[i], dpw0[i - 1])\n    dpw0[len(nums) - 1] = max(dpw0[len(nums) - 3] + nums[len(nums) - 1], dpw0[len(nums) - 2])\n\n    return max(dp[len(nums) - 2], dpw0[len(nums) - 1])\n</code></pre><code>class Solution:\n# @param {integer[]} nums\n# @return {integer}\ndef rob(self, nums):\n    if not nums:\n        return 0\n\n    if len(nums) == 1:\n        return nums[0]\n\n    if len(nums) == 2:\n        return max(nums[0], nums[1])\n\n    dp = {}\n    dpw0 = {}\n\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n    dpw0[0], dpw0[1] = 0, nums[1]\n\n\n    for i in range(2, len(nums) - 1):\n        dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\n        dpw0[i] = max(dpw0[i - 2] + nums[i], dpw0[i - 1])\n    dpw0[len(nums) - 1] = max(dpw0[len(nums) - 3] + nums[len(nums) - 1], dpw0[len(nums) - 2])\n\n    return max(dp[len(nums) - 2], dpw0[len(nums) - 1])\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "wangggong", "author_score": "120", "time": "2015-07-13T14:37:13+0000"}}], "title": "Python solution based on House Robber"}, {"question": {"content": "<pre><code>class TrieNode:\ndef __init__(self):\n    self.children = collections.defaultdict(TrieNode)\n    self.flag = False\n\nclass Solution:\ndef __init__(self):\n    self.root = TrieNode()\n    self.result = []\n\ndef insert(self, word):\n    node = self.root\n    for letter in word:\n        node = node.children[letter]\n    node.flag = True\n\ndef findWords(self, board, words):\n    for w in words:\n        self.insert(w)\n    for j in range(len(board)):\n        for i in range(len(board[0])):\n            self.dfs(self.root, board, j, i)\n    return self.result\n\ndef dfs(self, node, board, j, i, word=''):\n    if node.flag:\n        self.result.append(word)\n        node.flag = False\n    if 0 &lt;= j &lt; len(board) and 0 &lt;= i &lt; len(board[0]):\n        char = board[j][i]\n        child = node.children.get(char)\n        if child is not None:\n            word += char\n            board[j][i] = None\n            self.dfs(child, board, j + 1, i, word)\n            self.dfs(child, board, j - 1, i, word)\n            self.dfs(child, board, j, i + 1, word)\n            self.dfs(child, board, j, i - 1, word)\n            board[j][i] = char\n</code></pre><code>class TrieNode:\ndef __init__(self):\n    self.children = collections.defaultdict(TrieNode)\n    self.flag = False\n\nclass Solution:\ndef __init__(self):\n    self.root = TrieNode()\n    self.result = []\n\ndef insert(self, word):\n    node = self.root\n    for letter in word:\n        node = node.children[letter]\n    node.flag = True\n\ndef findWords(self, board, words):\n    for w in words:\n        self.insert(w)\n    for j in range(len(board)):\n        for i in range(len(board[0])):\n            self.dfs(self.root, board, j, i)\n    return self.result\n\ndef dfs(self, node, board, j, i, word=''):\n    if node.flag:\n        self.result.append(word)\n        node.flag = False\n    if 0 &lt;= j &lt; len(board) and 0 &lt;= i &lt; len(board[0]):\n        char = board[j][i]\n        child = node.children.get(char)\n        if child is not None:\n            word += char\n            board[j][i] = None\n            self.dfs(child, board, j + 1, i, word)\n            self.dfs(child, board, j - 1, i, word)\n            self.dfs(child, board, j, i + 1, word)\n            self.dfs(child, board, j, i - 1, word)\n            board[j][i] = char\n</code>", "votes": {"down": "1", "up": "2"}, "meta": {"author": "tusizi", "catagory": "Word Search II", "author_score": "20,650", "time": "2015-05-19T15:59:27+0000"}}, "answers": [], "title": "Python AC solution"}, {"question": {"content": "<pre><code>class Solution:\n\ndef minSubArrayLen(self, s, nums):\n    total = left = 0\n    result = len(nums) + 1\n    for right, n in enumerate(nums):\n        total += n\n        while total &gt;= s:\n            result = min(result, right - left + 1)\n            total -= nums[left]\n            left += 1\n    return result if result &lt;= len(nums) else 0\n</code></pre><code>class Solution:\n\ndef minSubArrayLen(self, s, nums):\n    total = left = 0\n    result = len(nums) + 1\n    for right, n in enumerate(nums):\n        total += n\n        while total &gt;= s:\n            result = min(result, right - left + 1)\n            total -= nums[left]\n            left += 1\n    return result if result &lt;= len(nums) else 0\n</code><p>O(n log n)</p><pre><code>class Solution:\n\ndef minSubArrayLen(self, target, nums):\n    result = len(nums) + 1\n    for idx, n in enumerate(nums[1:], 1):\n        nums[idx] = nums[idx - 1] + n\n    left = 0\n    for right, n in enumerate(nums):\n        if n &gt;= target:\n            left = self.find_left(left, right, nums, target, n)\n            result = min(result, right - left + 1)\n    return result if result &lt;= len(nums) else 0\n\ndef find_left(self, left, right, nums, target, n):\n    while left &lt; right:\n        mid = (left + right) // 2\n        if n - nums[mid] &gt;= target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n</code></pre><code>class Solution:\n\ndef minSubArrayLen(self, target, nums):\n    result = len(nums) + 1\n    for idx, n in enumerate(nums[1:], 1):\n        nums[idx] = nums[idx - 1] + n\n    left = 0\n    for right, n in enumerate(nums):\n        if n &gt;= target:\n            left = self.find_left(left, right, nums, target, n)\n            result = min(result, right - left + 1)\n    return result if result &lt;= len(nums) else 0\n\ndef find_left(self, left, right, nums, target, n):\n    while left &lt; right:\n        mid = (left + right) // 2\n        if n - nums[mid] &gt;= target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n</code>", "votes": {"down": "0", "up": "2"}, "meta": {"author": "tusizi", "catagory": "Minimum Size Subarray Sum", "author_score": "20,650", "time": "2015-05-19T13:51:35+0000"}, "comments": [{"content": "<p>The worst case of the nested loop is O(n^2) in the first solution, isn't it?</p>", "votes": null, "meta": {"author": "ChesterL", "author_score": "170", "time": "2015-06-08T12:01:58+0000"}}, {"content": "<p>no, it's not. cuz in total we only do O(n) subtractions. (we do subtraction to make length shorter, and the max length is n.) </p>", "votes": null, "meta": {"author": "liji94188", "author_score": "1,820", "time": "2015-07-21T05:22:16+0000"}}]}, "answers": [], "title": "Python O(n) and O(n log n) solution"}, {"question": {"content": "<pre><code>class TrieNode:\ndef __init__(self):\n    self.children = collections.defaultdict(TrieNode)\n    self.is_word = False\n\nclass WordDictionary:\ndef __init__(self):\n    self.root = TrieNode()\n\ndef addWord(self, word):\n    node = self.root\n    for letter in word:\n        node = node.children[letter]\n    node.is_word = True\n\ndef search(self, word):\n    stack = [self.root]\n    for letter in word:\n        level = []\n        while stack:\n            node = stack.pop()\n            if letter == '.':\n                level.extend(node.children.values())\n            else:\n                child = node.children.get(letter)\n                if child is not None:\n                    level.append(child)\n        stack = level\n    return any(node.is_word for node in stack)\n</code></pre><code>class TrieNode:\ndef __init__(self):\n    self.children = collections.defaultdict(TrieNode)\n    self.is_word = False\n\nclass WordDictionary:\ndef __init__(self):\n    self.root = TrieNode()\n\ndef addWord(self, word):\n    node = self.root\n    for letter in word:\n        node = node.children[letter]\n    node.is_word = True\n\ndef search(self, word):\n    stack = [self.root]\n    for letter in word:\n        level = []\n        while stack:\n            node = stack.pop()\n            if letter == '.':\n                level.extend(node.children.values())\n            else:\n                child = node.children.get(letter)\n                if child is not None:\n                    level.append(child)\n        stack = level\n    return any(node.is_word for node in stack)\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Add and Search Word - Data structure design", "author_score": "20,650", "time": "2015-05-19T12:54:18+0000"}}, "answers": [{"content": "<p>Judging by the \"Accepted Solutions Runtime Distribution\" diagram on the submission detail pages, there are quite a few faster ones.</p><p>Btw, you could use <code>for node in stack:</code>. Definitely clearer and shorter, and maybe faster. And maybe rename <code>stack</code>, as it's not really a stack. Also, <code>if child:</code> is nicer, the <code>is not None</code> is pointless.</p><code>for node in stack:</code><code>stack</code><code>if child:</code><code>is not None</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "StefanPochmann", "author_score": "75,020", "time": "2015-05-23T14:44:30+0000"}}, {"content": "<pre><code>def search(self, word):\n    cur=[self.root]\n    for i in word:\n        next=[]\n        if len(cur)==0:  # can stop here\n            return False\n        for j in cur:\n            if i=='.':\n                next.extend(j.child.values())\n            else:\n                j=j.child.get(i)\n                if j!=None:\n                    next.append(j)\n        cur=next\n    return any(tmp.end for tmp in cur)\n</code></pre><code>def search(self, word):\n    cur=[self.root]\n    for i in word:\n        next=[]\n        if len(cur)==0:  # can stop here\n            return False\n        for j in cur:\n            if i=='.':\n                next.extend(j.child.values())\n            else:\n                j=j.child.get(i)\n                if j!=None:\n                    next.append(j)\n        cur=next\n    return any(tmp.end for tmp in cur)\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "huashiyiqike", "author_score": "200", "time": "2015-05-23T03:53:39+0000"}, "comments": [{"content": "<p>Well how much faster is it?</p>", "votes": null, "meta": {"author": "StefanPochmann", "author_score": "75,020", "time": "2015-05-23T14:31:21+0000"}}, {"content": "<p>Actually it is slower in judge, 652ms vs  636 ms, something to do with the data and the speed  issue of python.</p>", "votes": null, "meta": {"author": "huashiyiqike", "author_score": "200", "time": "2015-05-24T14:31:59+0000"}}]}], "title": "Python AC about 600ms. does someone hava a faster solution?"}, {"question": {"content": "<pre><code>class Solution:\n# @param {integer} numCourses\n# @param {integer[][]} prerequisites\n# @return {integer[]}\ndef findOrder(self, numCourses, prerequisites):\n    graph = collections.defaultdict(set)\n    neighbors = collections.defaultdict(set)\n    for course, pre in prerequisites:\n        graph[course].add(pre)\n        neighbors[pre].add(course)\n    stack = [n for n in range(numCourses) if not graph[n]]\n    result = []\n    while stack:\n        node = stack.pop()\n        result.append(node)\n        for n in neighbors[node]:\n            graph[n].remove(node)\n            if not graph[n]:\n                stack.append(n)\n    return result if len(result) == numCourses else []\n</code></pre><code>class Solution:\n# @param {integer} numCourses\n# @param {integer[][]} prerequisites\n# @return {integer[]}\ndef findOrder(self, numCourses, prerequisites):\n    graph = collections.defaultdict(set)\n    neighbors = collections.defaultdict(set)\n    for course, pre in prerequisites:\n        graph[course].add(pre)\n        neighbors[pre].add(course)\n    stack = [n for n in range(numCourses) if not graph[n]]\n    result = []\n    while stack:\n        node = stack.pop()\n        result.append(node)\n        for n in neighbors[node]:\n            graph[n].remove(node)\n            if not graph[n]:\n                stack.append(n)\n    return result if len(result) == numCourses else []\n</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "tusizi", "catagory": "Course Schedule II", "author_score": "20,650", "time": "2015-05-18T17:41:45+0000"}}, "answers": [{"content": "<p>Same idea as yours...even the code is identical..hahaha</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "kexi", "author_score": "80", "time": "2015-07-01T06:21:27+0000"}}], "title": "Python Topological Sort"}, {"question": {"content": "<pre><code>class TrieNode:\n# Initialize your data structure here.\ndef __init__(self):\n    self.children = collections.defaultdict(TrieNode)\n    self.is_word = False\n\nclass Trie:\n\ndef __init__(self):\n    self.root = TrieNode()\n\ndef insert(self, word):\n    current = self.root\n    for letter in word:\n        current = current.children[letter]\n    current.is_word = True\n\ndef search(self, word):\n    current = self.root\n    for letter in word:\n        current = current.children.get(letter)\n        if current is None:\n            return False\n    return current.is_word\n\ndef startsWith(self, prefix):\n    current = self.root\n    for letter in prefix:\n        current = current.children.get(letter)\n        if current is None:\n            return False\n    return True\n</code></pre><code>class TrieNode:\n# Initialize your data structure here.\ndef __init__(self):\n    self.children = collections.defaultdict(TrieNode)\n    self.is_word = False\n\nclass Trie:\n\ndef __init__(self):\n    self.root = TrieNode()\n\ndef insert(self, word):\n    current = self.root\n    for letter in word:\n        current = current.children[letter]\n    current.is_word = True\n\ndef search(self, word):\n    current = self.root\n    for letter in word:\n        current = current.children.get(letter)\n        if current is None:\n            return False\n    return current.is_word\n\ndef startsWith(self, prefix):\n    current = self.root\n    for letter in prefix:\n        current = current.children.get(letter)\n        if current is None:\n            return False\n    return True\n</code>", "votes": {"down": "0", "up": "8"}, "meta": {"author": "tusizi", "catagory": "Implement Trie (Prefix Tree)", "author_score": "20,650", "time": "2015-05-18T14:24:02+0000"}}, "answers": [], "title": "AC Python Solution"}, {"question": {"content": "<pre><code>class Solution:\n# @param {integer} numCourses\n# @param {integer[][]} prerequisites\n# @return {boolean}\ndef canFinish(self, numCourses, prerequisites):\n    graph = collections.defaultdict(set)\n    neighbors = collections.defaultdict(set)\n    for course, pre in prerequisites:\n        graph[course].add(pre)\n        neighbors[pre].add(course)\n    stack = [n for n in range(numCourses) if not graph[n]]\n    count = 0\n    while stack:\n        node = stack.pop()\n        count += 1\n        for n in neighbors[node]:\n            graph[n].remove(node)\n            if not graph[n]:\n                stack.append(n)\n    return count == numCourses\n</code></pre><code>class Solution:\n# @param {integer} numCourses\n# @param {integer[][]} prerequisites\n# @return {boolean}\ndef canFinish(self, numCourses, prerequisites):\n    graph = collections.defaultdict(set)\n    neighbors = collections.defaultdict(set)\n    for course, pre in prerequisites:\n        graph[course].add(pre)\n        neighbors[pre].add(course)\n    stack = [n for n in range(numCourses) if not graph[n]]\n    count = 0\n    while stack:\n        node = stack.pop()\n        count += 1\n        for n in neighbors[node]:\n            graph[n].remove(node)\n            if not graph[n]:\n                stack.append(n)\n    return count == numCourses\n</code>", "votes": {"down": "0", "up": "2"}, "meta": {"author": "tusizi", "catagory": "Course Schedule", "author_score": "20,650", "time": "2015-05-18T11:57:38+0000"}}, "answers": [], "title": "Short Python Topological Sort"}, {"question": {"content": "<pre><code>class Solution:\n# @param {ListNode} head\n# @return {ListNode}\ndef reverseList(self, head):\n    prev = None\n    while head:\n        curr = head\n        head = head.next\n        curr.next = prev\n        prev = curr\n    return prev\n</code></pre><code>class Solution:\n# @param {ListNode} head\n# @return {ListNode}\ndef reverseList(self, head):\n    prev = None\n    while head:\n        curr = head\n        head = head.next\n        curr.next = prev\n        prev = curr\n    return prev\n</code><p>Recursion</p><pre><code>class Solution:\n# @param {ListNode} head\n# @return {ListNode}\ndef reverseList(self, head):\n    return self._reverse(head)\n\ndef _reverse(self, node, prev=None):\n    if not node:\n        return prev\n    n = node.next\n    node.next = prev\n    return self._reverse(n, node)\n</code></pre><code>class Solution:\n# @param {ListNode} head\n# @return {ListNode}\ndef reverseList(self, head):\n    return self._reverse(head)\n\ndef _reverse(self, node, prev=None):\n    if not node:\n        return prev\n    n = node.next\n    node.next = prev\n    return self._reverse(n, node)\n</code>", "votes": {"down": "0", "up": "5"}, "meta": {"author": "tusizi", "catagory": "Reverse Linked List", "author_score": "20,650", "time": "2015-05-16T11:51:19+0000"}, "comments": [{"content": "<p>Impressive solution , Could you please explain me time complexity?\nAs far I know iterative solution is taking more time because of while loop (so it may be bigO(n))\nbut I am not sure about recursive solution? Will you please explain me?</p>", "votes": null, "meta": {"author": "fatmazaman", "author_score": "100", "time": "2015-05-24T23:10:07+0000"}}, {"content": "<p>The two solutions are both O(n), we visit every node in the Linked List just once.</p>", "votes": null, "meta": {"author": "tusizi", "author_score": "20,650", "time": "2015-05-25T03:37:42+0000"}}, {"content": "<p>how do you compare space complexity?</p>", "votes": null, "meta": {"author": "rabeeh", "author_score": "1,080", "time": "2015-07-24T15:46:53+0000"}}]}, "answers": [{"content": "<p>and how do you compare the space complexity?</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "rabeeh", "author_score": "1,080", "time": "2015-07-24T15:46:24+0000"}}], "title": "Python Iterative and Recursive Solution"}, {"question": {"content": "<pre><code>class Solution:\n# @param {string} s\n# @param {string} t\n# @return {boolean}\ndef isIsomorphic(self, s, t):\n    s, t = str(s), str(t)\n    table1 = string.maketrans(s, t)\n    table2 = string.maketrans(t, s)\n    return s.translate(table1) == t and t.translate(table2) == s\n</code></pre><code>class Solution:\n# @param {string} s\n# @param {string} t\n# @return {boolean}\ndef isIsomorphic(self, s, t):\n    s, t = str(s), str(t)\n    table1 = string.maketrans(s, t)\n    table2 = string.maketrans(t, s)\n    return s.translate(table1) == t and t.translate(table2) == s\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Isomorphic Strings", "author_score": "20,650", "time": "2015-05-16T11:05:24+0000"}}, "answers": [], "title": "Short and Clear Python Code? String.translate"}, {"question": {"content": "<pre><code>class Solution:\n# @param {integer} n\n# @return {integer}\ndef countPrimes(self, n):\n    if n &lt; 3:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            primes[i * i: n: i] = [False] * len(primes[i * i: n: i])\n    return sum(primes)\n</code></pre><code>class Solution:\n# @param {integer} n\n# @return {integer}\ndef countPrimes(self, n):\n    if n &lt; 3:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            primes[i * i: n: i] = [False] * len(primes[i * i: n: i])\n    return sum(primes)\n</code>", "votes": {"down": "1", "up": "10"}, "meta": {"author": "tusizi", "catagory": "Count Primes", "author_score": "20,650", "time": "2015-05-16T08:32:24+0000"}}, "answers": [], "title": "Fast Python Solution"}, {"question": {"content": "<pre><code>public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) {\n    List&lt;Interval&gt; result = new ArrayList&lt;Interval&gt;();\n    for (Interval i : intervals) {\n        if (newInterval == null || i.end &lt; newInterval.start)\n            result.add(i);\n        else if (i.start &gt; newInterval.end) {\n            result.add(newInterval);\n            result.add(i);\n            newInterval = null;\n        } else {\n            newInterval.start = Math.min(newInterval.start, i.start);\n            newInterval.end = Math.max(newInterval.end, i.end);\n        }\n    }\n    if (newInterval != null)\n        result.add(newInterval);\n    return result;\n}\n</code></pre><code>public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) {\n    List&lt;Interval&gt; result = new ArrayList&lt;Interval&gt;();\n    for (Interval i : intervals) {\n        if (newInterval == null || i.end &lt; newInterval.start)\n            result.add(i);\n        else if (i.start &gt; newInterval.end) {\n            result.add(newInterval);\n            result.add(i);\n            newInterval = null;\n        } else {\n            newInterval.start = Math.min(newInterval.start, i.start);\n            newInterval.end = Math.max(newInterval.end, i.end);\n        }\n    }\n    if (newInterval != null)\n        result.add(newInterval);\n    return result;\n}\n</code>", "votes": {"down": "0", "up": "5"}, "meta": {"author": "tusizi", "catagory": "Insert Interval", "author_score": "20,650", "time": "2015-04-24T10:58:58+0000"}}, "answers": [], "title": "Short java code"}, {"question": {"content": "<pre><code>public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] num) {\n    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    while (true) {\n        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();\n        for (int n : num)\n            res.add(n);\n        if (!result.isEmpty() &amp;&amp; res.equals(result.get(0)))\n            break;\n        result.add(res);\n        nextPermutation(num);\n    }\n    return result;\n}\n\npublic void nextPermutation(int[] num) {\n    int n = num.length;\n    for (int i = n - 2; i &gt;= 0; i--) {\n        for (int j = n - 1; j &gt; i; j--) {\n            if (num[j] &gt; num[i]) {\n                int temp = num[j];\n                num[j] = num[i];\n                num[i] = temp;\n                reverse(num, i + 1, n - 1);\n                return;\n            }\n        }\n    }\n    reverse(num, 0, n - 1);\n}\n\nprivate void reverse(int[] nums, int start, int end) {\n    while (start &lt; end) {\n        int temp = nums[start];\n        nums[start++] = nums[end];\n        nums[end--] = temp;\n    }\n}\n</code></pre><code>public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] num) {\n    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    while (true) {\n        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();\n        for (int n : num)\n            res.add(n);\n        if (!result.isEmpty() &amp;&amp; res.equals(result.get(0)))\n            break;\n        result.add(res);\n        nextPermutation(num);\n    }\n    return result;\n}\n\npublic void nextPermutation(int[] num) {\n    int n = num.length;\n    for (int i = n - 2; i &gt;= 0; i--) {\n        for (int j = n - 1; j &gt; i; j--) {\n            if (num[j] &gt; num[i]) {\n                int temp = num[j];\n                num[j] = num[i];\n                num[i] = temp;\n                reverse(num, i + 1, n - 1);\n                return;\n            }\n        }\n    }\n    reverse(num, 0, n - 1);\n}\n\nprivate void reverse(int[] nums, int start, int end) {\n    while (start &lt; end) {\n        int temp = nums[start];\n        nums[start++] = nums[end];\n        nums[end--] = temp;\n    }\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Permutations II", "author_score": "20,650", "time": "2015-04-23T11:18:58+0000"}}, "answers": [], "title": "Java solution based on next permutation, no extra space"}, {"question": {"content": "<pre><code>public ListNode removeElements(ListNode head, int val) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode current = dummy;\n    while (current.next != null) {\n        if (current.next.val == val)\n            current.next = current.next.next;\n        else\n            current = current.next;\n    }\n    return dummy.next;\n}\n</code></pre><code>public ListNode removeElements(ListNode head, int val) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode current = dummy;\n    while (current.next != null) {\n        if (current.next.val == val)\n            current.next = current.next.next;\n        else\n            current = current.next;\n    }\n    return dummy.next;\n}\n</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "tusizi", "catagory": "Remove Linked List Elements", "author_score": "20,650", "time": "2015-04-23T07:28:53+0000"}}, "answers": [], "title": "Java dummy head, about 10-lines"}, {"question": {"content": "<pre><code>public boolean isHappy(int n) {\n    HashSet&lt;Integer&gt; hashSet = new HashSet&lt;Integer&gt;();\n    while (!hashSet.contains(n)) {\n        hashSet.add(n);\n        int temp = 0;\n        while (n &gt; 0) {\n            temp += Math.pow(n % 10, 2);\n            n /= 10;\n        }\n        n = temp;\n    }\n    return n == 1;\n}\n</code></pre><code>public boolean isHappy(int n) {\n    HashSet&lt;Integer&gt; hashSet = new HashSet&lt;Integer&gt;();\n    while (!hashSet.contains(n)) {\n        hashSet.add(n);\n        int temp = 0;\n        while (n &gt; 0) {\n            temp += Math.pow(n % 10, 2);\n            n /= 10;\n        }\n        n = temp;\n    }\n    return n == 1;\n}\n</code>", "votes": {"down": "0", "up": "2"}, "meta": {"author": "tusizi", "catagory": "Happy Number", "author_score": "20,650", "time": "2015-04-22T10:17:21+0000"}}, "answers": [], "title": "Short Java code"}, {"question": {"content": "<pre><code>public int firstMissingPositive(int[] nums) {\n    int start = 0;\n    int end = nums.length - 1;\n    while (start &lt;= end) {\n        int index = nums[start] - 1;\n        if (index == start)\n            start++;\n        else if (index &lt; 0 || index &gt; end || nums[start] == nums[index])\n            nums[start] = nums[end--];\n        else {\n            nums[start] = nums[index];\n            nums[index] = index + 1;\n        }\n    }\n    return start + 1;\n}\n</code></pre><code>public int firstMissingPositive(int[] nums) {\n    int start = 0;\n    int end = nums.length - 1;\n    while (start &lt;= end) {\n        int index = nums[start] - 1;\n        if (index == start)\n            start++;\n        else if (index &lt; 0 || index &gt; end || nums[start] == nums[index])\n            nums[start] = nums[end--];\n        else {\n            nums[start] = nums[index];\n            nums[index] = index + 1;\n        }\n    }\n    return start + 1;\n}\n</code>", "votes": {"down": "0", "up": "9"}, "meta": {"author": "tusizi", "catagory": "First Missing Positive", "author_score": "20,650", "time": "2015-04-21T09:10:01+0000"}}, "answers": [], "title": "Clear Java solution"}, {"question": {"content": "<pre><code>public ListNode reverseKGroup(ListNode head, int k) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode temp = dummy;\n    ListNode current = head;\n    ListNode reverse = null;\n    while (current != null) {\n        ListNode reverseHead = temp;\n        ListNode reverseTail = temp.next;\n        temp = temp.next;\n        for (int i = 0; i &lt; k; i++) {\n            if (current == null)\n                return dummy.next;\n            current = current.next;\n        }\n        current = temp;\n        for (int i = 0; i &lt; k; i++) {\n            current = current.next;\n            temp.next = reverse;\n            reverse = temp;\n            temp = current;\n        }\n        reverseHead.next = reverse;\n        reverseTail.next = current;\n        reverse = null;\n        temp = reverseTail;\n    }\n    return dummy.next;\n}\n</code></pre><code>public ListNode reverseKGroup(ListNode head, int k) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode temp = dummy;\n    ListNode current = head;\n    ListNode reverse = null;\n    while (current != null) {\n        ListNode reverseHead = temp;\n        ListNode reverseTail = temp.next;\n        temp = temp.next;\n        for (int i = 0; i &lt; k; i++) {\n            if (current == null)\n                return dummy.next;\n            current = current.next;\n        }\n        current = temp;\n        for (int i = 0; i &lt; k; i++) {\n            current = current.next;\n            temp.next = reverse;\n            reverse = temp;\n            temp = current;\n        }\n        reverseHead.next = reverse;\n        reverseTail.next = current;\n        reverse = null;\n        temp = reverseTail;\n    }\n    return dummy.next;\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Reverse Nodes in k-Group", "author_score": "20,650", "time": "2015-04-15T09:58:45+0000"}}, "answers": [], "title": "Java O(n) time, O(1) space solution"}, {"question": {"content": "<pre><code>public String fractionToDecimal(int numerator, int denominator) {\n    StringBuilder result = new StringBuilder();\n    String sign = (numerator &lt; 0 == denominator &lt; 0 || numerator == 0) ? \"\" : \"-\";\n    long num = Math.abs((long) numerator);\n    long den = Math.abs((long) denominator);\n    result.append(sign);\n    result.append(num / den);\n    long remainder = num % den;\n    if (remainder == 0)\n        return result.toString();\n    result.append(\".\");\n    HashMap&lt;Long, Integer&gt; hashMap = new HashMap&lt;Long, Integer&gt;();\n    while (!hashMap.containsKey(remainder)) {\n        hashMap.put(remainder, result.length());\n        result.append(10 * remainder / den);\n        remainder = 10 * remainder % den;\n    }\n    int index = hashMap.get(remainder);\n    result.insert(index, \"(\");\n    result.append(\")\");\n    return result.toString().replace(\"(0)\", \"\");\n}\n</code></pre><code>public String fractionToDecimal(int numerator, int denominator) {\n    StringBuilder result = new StringBuilder();\n    String sign = (numerator &lt; 0 == denominator &lt; 0 || numerator == 0) ? \"\" : \"-\";\n    long num = Math.abs((long) numerator);\n    long den = Math.abs((long) denominator);\n    result.append(sign);\n    result.append(num / den);\n    long remainder = num % den;\n    if (remainder == 0)\n        return result.toString();\n    result.append(\".\");\n    HashMap&lt;Long, Integer&gt; hashMap = new HashMap&lt;Long, Integer&gt;();\n    while (!hashMap.containsKey(remainder)) {\n        hashMap.put(remainder, result.length());\n        result.append(10 * remainder / den);\n        remainder = 10 * remainder % den;\n    }\n    int index = hashMap.get(remainder);\n    result.insert(index, \"(\");\n    result.append(\")\");\n    return result.toString().replace(\"(0)\", \"\");\n}\n</code>", "votes": {"down": "0", "up": "15"}, "meta": {"author": "tusizi", "catagory": "Fraction to Recurring Decimal", "author_score": "20,650", "time": "2015-04-12T11:09:01+0000"}}, "answers": [{"content": "<p>Nice answer, well done! Quite a nice way to think about the problem.</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "anirudh.dastidar", "author_score": "110", "time": "2015-05-04T19:42:34+0000"}}], "title": "Short Java solution"}, {"question": {"content": "<pre><code>public String reverseWords(String s) {\n    String[] words = s.trim().split(\" +\");\n    Collections.reverse(Arrays.asList(words));\n    return String.join(\" \", words);\n}\n</code></pre><code>public String reverseWords(String s) {\n    String[] words = s.trim().split(\" +\");\n    Collections.reverse(Arrays.asList(words));\n    return String.join(\" \", words);\n}\n</code>", "votes": {"down": "4", "up": "10"}, "meta": {"author": "tusizi", "catagory": "Reverse Words in a String", "author_score": "20,650", "time": "2015-04-11T12:01:38+0000"}, "comments": [{"content": "<p>So clever you are!</p>", "votes": null, "meta": {"author": "cczz598", "author_score": "100", "time": "2015-04-12T08:02:21+0000"}}]}, "answers": [], "title": "Java 3-line builtin solution"}, {"question": {"content": "<pre><code>public int numIslands(char[][] grid) {\n    int count = 0;\n    for (int y = 0; y &lt; grid.length; y++) {\n        for (int x = 0; x &lt; grid[0].length; x++) {\n            if (grid[y][x] == '1') {\n                dfs(grid, y, x);\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nprivate void dfs(char[][] grid, int y, int x) {\n    grid[y][x] = '0';\n    Stack&lt;Integer&gt; yPos = new Stack&lt;Integer&gt;();\n    Stack&lt;Integer&gt; xPos = new Stack&lt;Integer&gt;();\n    yPos.push(y);\n    xPos.push(x);\n    int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    while (!yPos.isEmpty()) {\n        y = yPos.pop();\n        x = xPos.pop();\n        for (int[] d : dirs) {\n            int dy = y + d[0];\n            int dx = x + d[1];\n            if (dy &gt;= 0 &amp;&amp; dy &lt; grid.length &amp;&amp; dx &gt;= 0 &amp;&amp; dx &lt; grid[0].length &amp;&amp; grid[dy][dx] == '1') {\n                grid[dy][dx] = '0';\n                yPos.push(dy);\n                xPos.push(dx);\n            }\n        }\n    }\n}\n</code></pre><code>public int numIslands(char[][] grid) {\n    int count = 0;\n    for (int y = 0; y &lt; grid.length; y++) {\n        for (int x = 0; x &lt; grid[0].length; x++) {\n            if (grid[y][x] == '1') {\n                dfs(grid, y, x);\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nprivate void dfs(char[][] grid, int y, int x) {\n    grid[y][x] = '0';\n    Stack&lt;Integer&gt; yPos = new Stack&lt;Integer&gt;();\n    Stack&lt;Integer&gt; xPos = new Stack&lt;Integer&gt;();\n    yPos.push(y);\n    xPos.push(x);\n    int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    while (!yPos.isEmpty()) {\n        y = yPos.pop();\n        x = xPos.pop();\n        for (int[] d : dirs) {\n            int dy = y + d[0];\n            int dx = x + d[1];\n            if (dy &gt;= 0 &amp;&amp; dy &lt; grid.length &amp;&amp; dx &gt;= 0 &amp;&amp; dx &lt; grid[0].length &amp;&amp; grid[dy][dx] == '1') {\n                grid[dy][dx] = '0';\n                yPos.push(dy);\n                xPos.push(dx);\n            }\n        }\n    }\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Number of Islands", "author_score": "20,650", "time": "2015-04-08T09:57:09+0000"}}, "answers": [], "title": "Common Java DFS"}, {"question": {"content": "<pre><code>public int ladderLength(String start, String end, Set&lt;String&gt; dict) {\n    LinkedList&lt;String&gt; queue = new LinkedList&lt;String&gt;();\n    queue.add(start);\n    dict.add(end);\n    int step = 0;\n    while (!queue.isEmpty()) {\n        LinkedList&lt;String&gt; level = new LinkedList&lt;String&gt;();\n        step++;\n        while (!queue.isEmpty()) {\n            String q = queue.pollFirst();\n            if (q.equals(end))\n                return step;\n            for (int i = 0; i &lt; start.length(); i++) {\n                for (char c = 'a'; c &lt;= 'z'; c++) {\n                    String s = q.substring(0, i) + c + q.substring(i + 1, start.length());\n                    if (dict.contains(s)) {\n                        level.add(s);\n                        dict.remove(s);\n                    }\n                }\n            }\n        }\n        queue = level;\n    }\n    return 0;\n}\n</code></pre><code>public int ladderLength(String start, String end, Set&lt;String&gt; dict) {\n    LinkedList&lt;String&gt; queue = new LinkedList&lt;String&gt;();\n    queue.add(start);\n    dict.add(end);\n    int step = 0;\n    while (!queue.isEmpty()) {\n        LinkedList&lt;String&gt; level = new LinkedList&lt;String&gt;();\n        step++;\n        while (!queue.isEmpty()) {\n            String q = queue.pollFirst();\n            if (q.equals(end))\n                return step;\n            for (int i = 0; i &lt; start.length(); i++) {\n                for (char c = 'a'; c &lt;= 'z'; c++) {\n                    String s = q.substring(0, i) + c + q.substring(i + 1, start.length());\n                    if (dict.contains(s)) {\n                        level.add(s);\n                        dict.remove(s);\n                    }\n                }\n            }\n        }\n        queue = level;\n    }\n    return 0;\n}\n</code>", "votes": {"down": "3", "up": "10"}, "meta": {"author": "tusizi", "catagory": "Word Ladder", "author_score": "20,650", "time": "2015-04-07T11:45:34+0000"}, "comments": [{"content": "<p>Time Limit Exceeded. Test before post.</p>", "votes": null, "meta": {"author": "liwang", "author_score": "1,440", "time": "2015-05-11T22:28:36+0000"}}, {"content": "<p>Time Limit Exceeded.</p>", "votes": null, "meta": {"author": "chennan", "author_score": "1,110", "time": "2015-05-12T19:57:31+0000"}}, {"content": "<p>It's better not to use string concatenation which would cause TLE. Try using toCharArray instead.</p>", "votes": null, "meta": {"author": "petrichory", "author_score": "450", "time": "2015-05-29T16:57:01+0000"}}]}, "answers": [{"content": "<pre><code>public int ladderLength(String start, String end, Set&lt;String&gt; dict) {\n    LinkedList&lt;String&gt; queue = new LinkedList&lt;String&gt;();\n    queue.add(start);\n    dict.add(end);\n    int step = 0;\n\n    while (!queue.isEmpty()) {\n        LinkedList&lt;String&gt; level = new LinkedList&lt;String&gt;();\n        step++;\n        while (!queue.isEmpty()) {\n            String q = queue.poll();\n            if(q.equals(end))\n                return step;\n\n            char[] t = q.toCharArray();\n            for(int i = 0; i &lt; start.length(); i++){\n                for(char c = 'a'; c &lt;= 'z'; c++){\n                    char temp = t[i];\n                    t[i] = c;\n                    String s = String.copyValueOf(t);\n                    t[i] = temp;\n                    if(dict.contains(s)){\n                        level.add(s);\n                        dict.remove(s);\n                    }\n                }\n            }\n        }\n        queue = level;\n    }\n\n    return 0;\n}\n</code></pre><code>public int ladderLength(String start, String end, Set&lt;String&gt; dict) {\n    LinkedList&lt;String&gt; queue = new LinkedList&lt;String&gt;();\n    queue.add(start);\n    dict.add(end);\n    int step = 0;\n\n    while (!queue.isEmpty()) {\n        LinkedList&lt;String&gt; level = new LinkedList&lt;String&gt;();\n        step++;\n        while (!queue.isEmpty()) {\n            String q = queue.poll();\n            if(q.equals(end))\n                return step;\n\n            char[] t = q.toCharArray();\n            for(int i = 0; i &lt; start.length(); i++){\n                for(char c = 'a'; c &lt;= 'z'; c++){\n                    char temp = t[i];\n                    t[i] = c;\n                    String s = String.copyValueOf(t);\n                    t[i] = temp;\n                    if(dict.contains(s)){\n                        level.add(s);\n                        dict.remove(s);\n                    }\n                }\n            }\n        }\n        queue = level;\n    }\n\n    return 0;\n}\n</code><p>The solution is pretty good. I modify the part of string concatenation and it runs with 476 ms.</p>", "votes": {"down": "0", "up": "8"}, "meta": {"author": "lzyfriday", "catagory": "Word Ladder", "author_score": "660", "time": "2015-06-22T09:04:21+0000"}, "best_answer": true, "comments": [{"content": "<p>pretty good answers ,expand my views</p>", "votes": null, "meta": {"author": "stealflowercow", "author_score": "300", "time": "2015-07-13T02:37:55+0000"}}]}, {"content": "<p>The code is mostly good.</p><p>change <code>queue.pollFirst()</code> to <code>queue.poll()</code>, TLE should be gone.</p><code>queue.pollFirst()</code><code>queue.poll()</code>", "votes": {"down": "1", "up": "1"}, "meta": {"author": "chennan", "author_score": "1,110", "time": "2015-05-12T20:21:17+0000"}, "comments": [{"content": "<p>pollFirst() and poll() are same, still have TLE.\n</p><pre>\n   public E poll() {\n        final Node f = first;\n        return (f == null) ? null : unlinkFirst(f);\n    }\n</pre><pre>\n   public E pollFirst() {\n        final Node f = first;\n        return (f == null) ? null : unlinkFirst(f);\n    }\n</pre>", "votes": null, "meta": {"author": "zhanqing", "author_score": "1,900", "time": "2015-06-04T22:54:37+0000"}}]}, {"content": "<pre><code>public int ladderLength(String beginWord, String endWord, Set&lt;String&gt; wordDict) {\n\n    int path = 0;\n    if(beginWord.equals(endWord)) return ++path;\n\n    Queue&lt;String&gt; bfs = new LinkedList&lt;&gt;();\n    bfs.add(\"0\");\n    bfs.add(beginWord);\n    wordDict.remove(beginWord);\n\n    while(bfs.size() &gt; 1){\n        String curr = bfs.remove();\n        if(curr.equals(\"0\")){\n            path++;\n            bfs.add(curr);\n        }else{\n            String nbr = \"\";\n            //Generate all adjacent words of curr\n            for(int i=0; i&lt;curr.length(); i++){\n                for(char c = 'a'; c&lt;= 'z'; c++){\n                        nbr = curr.substring(0,i)+c+curr.substring(i+1);\n                        if(endWord.equals(nbr)) return ++path;\n                        if(wordDict.remove(nbr)){\n                             bfs.add(nbr);\n                        }\n                }\n            } //for\n        } //if/else\n    }//end of while\n    return 0;\n}\n</code></pre><code>public int ladderLength(String beginWord, String endWord, Set&lt;String&gt; wordDict) {\n\n    int path = 0;\n    if(beginWord.equals(endWord)) return ++path;\n\n    Queue&lt;String&gt; bfs = new LinkedList&lt;&gt;();\n    bfs.add(\"0\");\n    bfs.add(beginWord);\n    wordDict.remove(beginWord);\n\n    while(bfs.size() &gt; 1){\n        String curr = bfs.remove();\n        if(curr.equals(\"0\")){\n            path++;\n            bfs.add(curr);\n        }else{\n            String nbr = \"\";\n            //Generate all adjacent words of curr\n            for(int i=0; i&lt;curr.length(); i++){\n                for(char c = 'a'; c&lt;= 'z'; c++){\n                        nbr = curr.substring(0,i)+c+curr.substring(i+1);\n                        if(endWord.equals(nbr)) return ++path;\n                        if(wordDict.remove(nbr)){\n                             bfs.add(nbr);\n                        }\n                }\n            } //for\n        } //if/else\n    }//end of while\n    return 0;\n}\n</code>", "votes": {"down": "1", "up": "0"}, "meta": {"author": "sanket.purbey", "author_score": "90", "time": "2015-05-30T21:16:24+0000"}, "comments": [{"content": "<p>time limit~~~</p>", "votes": null, "meta": {"author": "feiger123", "author_score": "170", "time": "2015-06-02T15:40:49+0000"}}]}], "title": "Short Java BFS solution"}, {"question": {"content": "<pre><code>private TreeNode prev = null;\n\npublic void flatten(TreeNode root) {\n    if (root == null)\n        return;\n    flatten(root.right);\n    flatten(root.left);\n    root.right = prev;\n    root.left = null;\n    prev = root;\n}\n</code></pre><code>private TreeNode prev = null;\n\npublic void flatten(TreeNode root) {\n    if (root == null)\n        return;\n    flatten(root.right);\n    flatten(root.left);\n    root.right = prev;\n    root.left = null;\n    prev = root;\n}\n</code>", "votes": {"down": "0", "up": "35"}, "meta": {"author": "tusizi", "catagory": "Flatten Binary Tree to Linked List", "author_score": "20,650", "time": "2015-04-06T10:52:22+0000"}, "comments": [{"content": "<p>Omg that's so clever</p>", "votes": null, "meta": {"author": "lufangjianle", "author_score": "580", "time": "2015-06-08T07:25:32+0000"}}, {"content": "<p>This is so freaking beautiful.</p>", "votes": null, "meta": {"author": "binshuo", "author_score": "130", "time": "2015-07-05T02:40:58+0000"}}, {"content": "<p>\u5929\u5566\u8fd9\u4e2a\u89e3\u6cd5\u771f\u662f\u592a\u5c4c\u4e86\uff01</p>", "votes": null, "meta": {"author": "\u6765\u4e00\u676f\u70ed\u67e0\u6aac\u6c34", "author_score": "130", "time": "2015-08-01T10:12:50+0000"}}]}, "answers": [{"content": "<p>It took a while to get the idea. Man it is beautiful!</p>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "sculd", "author_score": "890", "time": "2015-04-24T02:38:53+0000"}}], "title": "My short post order traversal Java solution for share"}, {"question": {"content": "<pre><code>public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {\n    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    if (root == null)\n        return result;\n    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();\n    Stack&lt;LinkedList&lt;Integer&gt;&gt; paths = new Stack&lt;LinkedList&lt;Integer&gt;&gt;();\n    stack.push(root);\n    paths.push(new LinkedList&lt;Integer&gt;(Arrays.asList(root.val, root.val)));\n    while (!stack.isEmpty()) {\n        TreeNode node = stack.pop();\n        LinkedList&lt;Integer&gt; path = paths.pop();\n        if (node.left == null &amp;&amp; node.right == null &amp;&amp; path.pollFirst() == sum)\n            result.add(path);\n        if (node.left != null) {\n            stack.push(node.left);\n            LinkedList&lt;Integer&gt; p = new LinkedList&lt;Integer&gt;(path);\n            p.add(node.left.val);\n            p.set(0, p.peekFirst() + p.peekLast());\n            paths.push(p);\n        }\n        if (node.right != null) {\n            stack.push(node.right);\n            LinkedList&lt;Integer&gt; p = new LinkedList&lt;Integer&gt;(path);\n            p.add(node.right.val);\n            p.set(0, p.peekFirst() + p.peekLast());\n            paths.push(p);\n        }\n    }\n    return result;\n}\n</code></pre><code>public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {\n    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    if (root == null)\n        return result;\n    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();\n    Stack&lt;LinkedList&lt;Integer&gt;&gt; paths = new Stack&lt;LinkedList&lt;Integer&gt;&gt;();\n    stack.push(root);\n    paths.push(new LinkedList&lt;Integer&gt;(Arrays.asList(root.val, root.val)));\n    while (!stack.isEmpty()) {\n        TreeNode node = stack.pop();\n        LinkedList&lt;Integer&gt; path = paths.pop();\n        if (node.left == null &amp;&amp; node.right == null &amp;&amp; path.pollFirst() == sum)\n            result.add(path);\n        if (node.left != null) {\n            stack.push(node.left);\n            LinkedList&lt;Integer&gt; p = new LinkedList&lt;Integer&gt;(path);\n            p.add(node.left.val);\n            p.set(0, p.peekFirst() + p.peekLast());\n            paths.push(p);\n        }\n        if (node.right != null) {\n            stack.push(node.right);\n            LinkedList&lt;Integer&gt; p = new LinkedList&lt;Integer&gt;(path);\n            p.add(node.right.val);\n            p.set(0, p.peekFirst() + p.peekLast());\n            paths.push(p);\n        }\n    }\n    return result;\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Path Sum II", "author_score": "20,650", "time": "2015-04-06T09:04:00+0000"}}, "answers": [], "title": "Share my iterative Java solution"}, {"question": {"content": "<pre><code>public ListNode reverseBetween(ListNode head, int m, int n) {\n    ListNode current = head;\n    ListNode reverseHead = null;\n    ListNode dummy = null;\n    ListNode tail = new ListNode(0);\n    for (int i = 1; i &lt;= n; i++) {\n        if (i == m - 1) {\n            reverseHead = current;\n        } else if (i &gt;= m) {\n            if (i == m)\n                tail = current;\n            ListNode node = current;\n            current = current.next;\n            node.next = dummy;\n            dummy = node;\n            continue;\n        }\n        current = current.next;\n    }\n    tail.next = current;\n    if (reverseHead == null)\n        return dummy;\n    else\n        reverseHead.next = dummy;\n    return head;\n}\n</code></pre><code>public ListNode reverseBetween(ListNode head, int m, int n) {\n    ListNode current = head;\n    ListNode reverseHead = null;\n    ListNode dummy = null;\n    ListNode tail = new ListNode(0);\n    for (int i = 1; i &lt;= n; i++) {\n        if (i == m - 1) {\n            reverseHead = current;\n        } else if (i &gt;= m) {\n            if (i == m)\n                tail = current;\n            ListNode node = current;\n            current = current.next;\n            node.next = dummy;\n            dummy = node;\n            continue;\n        }\n        current = current.next;\n    }\n    tail.next = current;\n    if (reverseHead == null)\n        return dummy;\n    else\n        reverseHead.next = dummy;\n    return head;\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Reverse Linked List II", "author_score": "20,650", "time": "2015-04-04T10:16:02+0000"}}, "answers": [], "title": "Java straight forward solution"}, {"question": {"content": "<pre><code>public List&lt;Integer&gt; rightSideView(TreeNode root) {\n    LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();\n    queue.add(root);\n    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n    while (!queue.isEmpty()) {\n        Integer rightSide = null;\n        int size = queue.size();\n        for (int i = 0; i &lt; size; i++) {\n            TreeNode q = queue.pollFirst();\n            if (q == null)\n                continue;\n            rightSide = q.val;\n            queue.add(q.left);\n            queue.add(q.right);\n        }\n        if (rightSide != null)\n            result.add(rightSide);\n    }\n    return result;\n}\n</code></pre><code>public List&lt;Integer&gt; rightSideView(TreeNode root) {\n    LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();\n    queue.add(root);\n    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n    while (!queue.isEmpty()) {\n        Integer rightSide = null;\n        int size = queue.size();\n        for (int i = 0; i &lt; size; i++) {\n            TreeNode q = queue.pollFirst();\n            if (q == null)\n                continue;\n            rightSide = q.val;\n            queue.add(q.left);\n            queue.add(q.right);\n        }\n        if (rightSide != null)\n            result.add(rightSide);\n    }\n    return result;\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Binary Tree Right Side View", "author_score": "20,650", "time": "2015-04-04T08:53:04+0000"}}, "answers": [], "title": "Short Java BFS solution"}, {"question": {"content": "<pre><code>public ListNode deleteDuplicates(ListNode head) {\n    ListNode dummy = new ListNode(0);\n    ListNode d = dummy;\n    while (head != null) {\n        if (head.next != null &amp;&amp; head.val == head.next.val) {\n            while (head.next != null &amp;&amp; head.val == head.next.val)\n                head = head.next;\n        } else {\n            d.next = head;\n            d = d.next;\n        }\n        head = head.next;\n    }\n    d.next = null;\n    return dummy.next;\n}\n</code></pre><code>public ListNode deleteDuplicates(ListNode head) {\n    ListNode dummy = new ListNode(0);\n    ListNode d = dummy;\n    while (head != null) {\n        if (head.next != null &amp;&amp; head.val == head.next.val) {\n            while (head.next != null &amp;&amp; head.val == head.next.val)\n                head = head.next;\n        } else {\n            d.next = head;\n            d = d.next;\n        }\n        head = head.next;\n    }\n    d.next = null;\n    return dummy.next;\n}\n</code><p>1-&gt;1-&gt;1-&gt;2-&gt;2-&gt;3</p><p>we skip all the 1's and start the loop from 2</p><p>and also skip all the 2's, and now head.val == 3;</p><p>ponit d.next to the tail, end the loop</p>", "votes": {"down": "0", "up": "2"}, "meta": {"author": "tusizi", "catagory": "Remove Duplicates from Sorted List II", "author_score": "20,650", "time": "2015-04-02T13:37:09+0000"}}, "answers": [], "title": "A short and simple Java solution"}, {"question": {"content": "<pre><code>public boolean search(int[] A, int target) {\n    int start = 0;\n    int end = A.length - 1;\n    while (start &lt;= end) {\n        int mid = start + (end - start) / 2;\n        if (A[mid] == target) // case 0\n            return true;\n        // finally start == mid == end, if case 0, return true, else end the loop\n        else if (A[start] == A[mid])\n            start++;\n        else if (A[end] == A[mid])\n            end--;\n        else if (A[start] &lt;= target &amp;&amp; target &lt;= A[mid]) // case 1\n            end = mid;\n        else if (A[mid] &lt; target &amp;&amp; target &lt;= A[end]) // case 2\n            start = mid + 1;\n        else if (A[start] &gt; A[mid]) // case 2 is false, so target in this range\n            end = mid;\n        else   // case A[mid] &gt; A[end] and case 1 is false, similar to above\n            start = mid + 1;\n    }\n    return false;\n}\n</code></pre><code>public boolean search(int[] A, int target) {\n    int start = 0;\n    int end = A.length - 1;\n    while (start &lt;= end) {\n        int mid = start + (end - start) / 2;\n        if (A[mid] == target) // case 0\n            return true;\n        // finally start == mid == end, if case 0, return true, else end the loop\n        else if (A[start] == A[mid])\n            start++;\n        else if (A[end] == A[mid])\n            end--;\n        else if (A[start] &lt;= target &amp;&amp; target &lt;= A[mid]) // case 1\n            end = mid;\n        else if (A[mid] &lt; target &amp;&amp; target &lt;= A[end]) // case 2\n            start = mid + 1;\n        else if (A[start] &gt; A[mid]) // case 2 is false, so target in this range\n            end = mid;\n        else   // case A[mid] &gt; A[end] and case 1 is false, similar to above\n            start = mid + 1;\n    }\n    return false;\n}\n</code>", "votes": {"down": "0", "up": "3"}, "meta": {"author": "tusizi", "catagory": "Search in Rotated Sorted Array II", "author_score": "20,650", "time": "2015-04-02T12:05:55+0000"}, "comments": [{"content": "<p>int mid = (start + end ) / 2;</p>", "votes": null, "meta": {"author": "mingslin", "author_score": "100", "time": "2015-07-04T20:26:37+0000"}}]}, "answers": [], "title": "Java solution with comments"}, {"question": {"content": "<pre><code>public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {\n    LinkedList&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;();\n    result.add(new LinkedList&lt;Integer&gt;());\n    for (int j = k - 1; j &gt;= 0; j--) {\n        int size = result.size();\n        for (int i = 0; i &lt; size; i++) {\n            LinkedList&lt;Integer&gt; res = (LinkedList&lt;Integer&gt;) result.pollFirst();\n            int start = (res.isEmpty()) ? 0 : res.getLast();\n            for (int m = start + 1; m + j &lt;= n; m++) {\n                List&lt;Integer&gt; r = new LinkedList&lt;Integer&gt;(res);\n                r.add(m);\n                result.add(r);\n            }\n        }\n    }\n    return result;\n}\n</code></pre><code>public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {\n    LinkedList&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;();\n    result.add(new LinkedList&lt;Integer&gt;());\n    for (int j = k - 1; j &gt;= 0; j--) {\n        int size = result.size();\n        for (int i = 0; i &lt; size; i++) {\n            LinkedList&lt;Integer&gt; res = (LinkedList&lt;Integer&gt;) result.pollFirst();\n            int start = (res.isEmpty()) ? 0 : res.getLast();\n            for (int m = start + 1; m + j &lt;= n; m++) {\n                List&lt;Integer&gt; r = new LinkedList&lt;Integer&gt;(res);\n                r.add(m);\n                result.add(r);\n            }\n        }\n    }\n    return result;\n}\n</code><p>for combine(4, 2)</p><p>we generate(1,), (2,), (3,)</p><p>then (1,2),(1,3),(1,4),(2,3),(2,4),(3,4)</p><p>we generate every level from start+1 to n-j</p><p>for the number bigger than n-j, it is impossible to find a bigger number to complete the comb</p>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "tusizi", "catagory": "Combinations", "author_score": "20,650", "time": "2015-03-31T13:11:22+0000"}}, "answers": [], "title": "Simple java solution, generate comb from a bigger number"}, {"question": {"content": "<pre><code>public int rob(int[] num) {\n    int[][] dp = new int[num.length + 1][2];\n    for (int i = 1; i &lt;= num.length; i++) {\n        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);\n        dp[i][1] = num[i - 1] + dp[i - 1][0];\n    }\n    return Math.max(dp[num.length][0], dp[num.length][1]);\n}\n</code></pre><code>public int rob(int[] num) {\n    int[][] dp = new int[num.length + 1][2];\n    for (int i = 1; i &lt;= num.length; i++) {\n        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);\n        dp[i][1] = num[i - 1] + dp[i - 1][0];\n    }\n    return Math.max(dp[num.length][0], dp[num.length][1]);\n}\n</code><p>dp[i][1] means we rob the current house and dp[i][0] means we don't,</p><p>so it is easy to convert this to O(1) space</p><pre><code>public int rob(int[] num) {\n    int prevNo = 0;\n    int prevYes = 0;\n    for (int n : num) {\n        int temp = prevNo;\n        prevNo = Math.max(prevNo, prevYes);\n        prevYes = n + temp;\n    }\n    return Math.max(prevNo, prevYes);\n}\n</code></pre><code>public int rob(int[] num) {\n    int prevNo = 0;\n    int prevYes = 0;\n    for (int n : num) {\n        int temp = prevNo;\n        prevNo = Math.max(prevNo, prevYes);\n        prevYes = n + temp;\n    }\n    return Math.max(prevNo, prevYes);\n}\n</code>", "votes": {"down": "0", "up": "38"}, "meta": {"author": "tusizi", "catagory": "House Robber", "author_score": "20,650", "time": "2015-03-31T09:10:10+0000"}, "comments": [{"content": "<p>nice and readable solution\uff01</p>", "votes": null, "meta": {"author": "kxcf", "author_score": "5,240", "time": "2015-04-01T15:33:36+0000"}}, {"content": "<p>I can hardly understand  your solution:\nMy questions are: \nWhy do you call it a easy solution?\nWhat can  I do to develop a similar mind for questions like this? Did you make any reference or you came up with this idea by your own?</p>", "votes": null, "meta": {"author": "steven10", "author_score": "140", "time": "2015-04-03T16:07:56+0000"}}, {"content": "<p>please check \"dynamic programming\"</p>", "votes": null, "meta": {"author": "chennan", "author_score": "1,110", "time": "2015-05-21T19:09:19+0000"}}, {"content": "<p>Thanks a lot!!!!</p>", "votes": null, "meta": {"author": "steven10", "author_score": "140", "time": "2015-05-21T22:40:39+0000"}}]}, "answers": [{"content": "<p>For all those who are looking for explanation for this problem, here is my code with comments. Same logic.</p><pre><code>public static int rob(int[] nums) \n    {\n        int ifRobbedPrevious = 0;   // max monney can get if rob current house\n        int ifDidntRobPrevious = 0; // max money can get if not rob current house\n\n        // We go through all the values, we maintain two counts, 1) if we rob this cell, 2) if we didn't rob this cell\n        for(int i=0; i &lt; nums.length; i++) \n        {\n            // If we rob current cell, previous cell shouldn't be robbed. So, add the current value to previous one.\n            int currRobbed = ifDidntRobPrevious + nums[i];\n\n            // If we don't rob current cell, then the count should be max of the previous cell robbed and not robbed\n            int currNotRobbed = Math.max(ifDidntRobPrevious, ifRobbedPrevious); \n\n            // Update values for the next round\n            ifDidntRobPrevious  = currNotRobbed;\n            ifRobbedPrevious = currRobbed;\n        }\n\n        return Math.max(ifRobbedPrevious, ifDidntRobPrevious);\n    }\n</code></pre><code>public static int rob(int[] nums) \n    {\n        int ifRobbedPrevious = 0;   // max monney can get if rob current house\n        int ifDidntRobPrevious = 0; // max money can get if not rob current house\n\n        // We go through all the values, we maintain two counts, 1) if we rob this cell, 2) if we didn't rob this cell\n        for(int i=0; i &lt; nums.length; i++) \n        {\n            // If we rob current cell, previous cell shouldn't be robbed. So, add the current value to previous one.\n            int currRobbed = ifDidntRobPrevious + nums[i];\n\n            // If we don't rob current cell, then the count should be max of the previous cell robbed and not robbed\n            int currNotRobbed = Math.max(ifDidntRobPrevious, ifRobbedPrevious); \n\n            // Update values for the next round\n            ifDidntRobPrevious  = currNotRobbed;\n            ifRobbedPrevious = currRobbed;\n        }\n\n        return Math.max(ifRobbedPrevious, ifDidntRobPrevious);\n    }\n</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "san89kalp", "author_score": "170", "time": "2015-08-19T02:33:59+0000"}}, {"content": "<p>Share my c++ version for your reference</p><pre><code>class Solution {\n    public:\n        int rob(vector&lt;int&gt; &amp;num) {\n            int n = num.size();\n            if (n==0) return 0;\n            vector&lt;int&gt; result(n+1,0);\n            result[1] = num[0];\n            for (int i=2;i&lt;=n;i++){\n                result[i] = max(result[i-1],result[i-2]+num[i-1]);\n            }\n            return result[n];\n\n\n        }\n };\n</code></pre><code>class Solution {\n    public:\n        int rob(vector&lt;int&gt; &amp;num) {\n            int n = num.size();\n            if (n==0) return 0;\n            vector&lt;int&gt; result(n+1,0);\n            result[1] = num[0];\n            for (int i=2;i&lt;=n;i++){\n                result[i] = max(result[i-1],result[i-2]+num[i-1]);\n            }\n            return result[n];\n\n\n        }\n };\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "GYX", "author_score": "200", "time": "2015-03-31T14:24:00+0000"}}], "title": "Java O(n) solution, space O(1)"}, {"question": {"content": "<pre><code>public String simplifyPath(String path) {\n    Stack&lt;String&gt; stack = new Stack&lt;String&gt;();\n    for (String s : path.split(\"/\")) {\n        if (s.equals(\"..\") &amp;&amp; !stack.isEmpty())\n            stack.pop();\n        else if (!s.equals(\".\") &amp;&amp; !s.equals(\"..\") &amp;&amp; !s.equals(\"\"))\n            stack.push(s);\n    }\n    return \"/\" + String.join(\"/\", stack);\n}\n</code></pre><code>public String simplifyPath(String path) {\n    Stack&lt;String&gt; stack = new Stack&lt;String&gt;();\n    for (String s : path.split(\"/\")) {\n        if (s.equals(\"..\") &amp;&amp; !stack.isEmpty())\n            stack.pop();\n        else if (!s.equals(\".\") &amp;&amp; !s.equals(\"..\") &amp;&amp; !s.equals(\"\"))\n            stack.push(s);\n    }\n    return \"/\" + String.join(\"/\", stack);\n}\n</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "tusizi", "catagory": "Simplify Path", "author_score": "20,650", "time": "2015-03-30T18:17:09+0000"}}, "answers": [], "title": "Java already has the method String.join"}, {"question": {"content": "<pre><code>public int sqrt(int x) {\n    int low = 1; // mid always &gt;= 1;\n    int high = x;\n    int answer = 0; // skip loop when high is 0\n    while (low &lt;= high) {\n        int mid = low + (high - low) / 2;\n        if (mid &lt;= x / mid) {\n            low = mid + 1;\n            answer = mid;\n        } else\n            high = mid - 1;\n    }\n    return answer;\n}\n</code></pre><code>public int sqrt(int x) {\n    int low = 1; // mid always &gt;= 1;\n    int high = x;\n    int answer = 0; // skip loop when high is 0\n    while (low &lt;= high) {\n        int mid = low + (high - low) / 2;\n        if (mid &lt;= x / mid) {\n            low = mid + 1;\n            answer = mid;\n        } else\n            high = mid - 1;\n    }\n    return answer;\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Sqrt(x)", "author_score": "20,650", "time": "2015-03-29T16:53:01+0000"}}, "answers": [], "title": "Java Binary Search"}, {"question": {"content": "<pre><code>public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n    int width = obstacleGrid[0].length;\n    int[] dp = new int[width];\n    dp[0] = 1;\n    for (int[] row : obstacleGrid) {\n        for (int j = 0; j &lt; width; j++) {\n            if (row[j] == 1)\n                dp[j] = 0;\n            else if (j &gt; 0)\n                dp[j] += dp[j - 1];\n        }\n    }\n    return dp[width - 1];\n}\n</code></pre><code>public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n    int width = obstacleGrid[0].length;\n    int[] dp = new int[width];\n    dp[0] = 1;\n    for (int[] row : obstacleGrid) {\n        for (int j = 0; j &lt; width; j++) {\n            if (row[j] == 1)\n                dp[j] = 0;\n            else if (j &gt; 0)\n                dp[j] += dp[j - 1];\n        }\n    }\n    return dp[width - 1];\n}\n</code>", "votes": {"down": "0", "up": "11"}, "meta": {"author": "tusizi", "catagory": "Unique Paths II", "author_score": "20,650", "time": "2015-03-29T15:48:33+0000"}, "comments": [{"content": "<p>Can you add more explanations? What does the dp array stand for?</p>", "votes": null, "meta": {"author": "seekerwu", "author_score": "100", "time": "2015-08-17T13:48:33+0000"}}]}, "answers": [], "title": "Short JAVA solution"}, {"question": {"content": "<pre><code>public List&lt;Integer&gt; spiralOrder(int[][] matrix) {\n    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n    int row = matrix.length;\n    if (row == 0)\n        return result;\n    int col = matrix[0].length;\n    int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    boolean[][] visited = new boolean[row][col];\n    int y = 0;\n    int x = 0;\n    int d = 0;\n    for (int i = 0; i &lt; row * col; i++) {\n        result.add(matrix[y][x]);\n        visited[y][x] = true;\n        int[] dir = dirs[d % 4];\n        if (y + dir[0] &lt; 0 || y + dir[0] &gt;= row || x + dir[1] &lt; 0 || x + dir[1] &gt;= col ||\n                visited[y + dir[0]][x + dir[1]])\n            dir = dirs[++d % 4];\n        y += dir[0];\n        x += dir[1];\n    }\n    return result;\n}\n</code></pre><code>public List&lt;Integer&gt; spiralOrder(int[][] matrix) {\n    List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n    int row = matrix.length;\n    if (row == 0)\n        return result;\n    int col = matrix[0].length;\n    int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    boolean[][] visited = new boolean[row][col];\n    int y = 0;\n    int x = 0;\n    int d = 0;\n    for (int i = 0; i &lt; row * col; i++) {\n        result.add(matrix[y][x]);\n        visited[y][x] = true;\n        int[] dir = dirs[d % 4];\n        if (y + dir[0] &lt; 0 || y + dir[0] &gt;= row || x + dir[1] &lt; 0 || x + dir[1] &gt;= col ||\n                visited[y + dir[0]][x + dir[1]])\n            dir = dirs[++d % 4];\n        y += dir[0];\n        x += dir[1];\n    }\n    return result;\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Spiral Matrix", "author_score": "20,650", "time": "2015-03-27T23:10:22+0000"}}, "answers": [], "title": "Simple JAVA solution use an extra visited array"}, {"question": {"content": "<pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) {\n    LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;List&lt;Integer&gt;&gt;();\n    res.add(new ArrayList&lt;Integer&gt;());\n    for (int n : num) {\n        int size = res.size();\n        for (; size &gt; 0; size--) {\n            List&lt;Integer&gt; r = res.pollFirst();\n            for (int i = 0; i &lt;= r.size(); i++) {\n                List&lt;Integer&gt; t = new ArrayList&lt;Integer&gt;(r);\n                t.add(i, n);\n                res.add(t);\n            }\n        }\n    }\n    return res;\n}\n</code></pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) {\n    LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;List&lt;Integer&gt;&gt;();\n    res.add(new ArrayList&lt;Integer&gt;());\n    for (int n : num) {\n        int size = res.size();\n        for (; size &gt; 0; size--) {\n            List&lt;Integer&gt; r = res.pollFirst();\n            for (int i = 0; i &lt;= r.size(); i++) {\n                List&lt;Integer&gt; t = new ArrayList&lt;Integer&gt;(r);\n                t.add(i, n);\n                res.add(t);\n            }\n        }\n    }\n    return res;\n}\n</code>", "votes": {"down": "0", "up": "11"}, "meta": {"author": "tusizi", "catagory": "Permutations", "author_score": "20,650", "time": "2015-03-26T11:26:37+0000"}}, "answers": [], "title": "Share my short iterative JAVA solution"}, {"question": {"content": "<pre><code>public String multiply(String num1, String num2) {\n    int len1 = num1.length();\n    int len2 = num2.length();\n    int[] product = new int[len1 + len2];\n    for (int i = len1 - 1; i &gt;= 0; i--) {\n        for (int j = len2 - 1; j &gt;= 0; j--) {\n            int index = len1 + len2 - i - j - 2;\n            product[index] += (num1.charAt(i) - '0') * (num2.charAt(j) - '0');\n            product[index + 1] += product[index] / 10;\n            product[index] %= 10;\n        }\n    }\n    StringBuilder stringBuilder = new StringBuilder();\n    for (int i = product.length - 1; i &gt; 0; i--) {\n        if (stringBuilder.length() == 0 &amp;&amp; product[i] == 0)\n            continue;\n        stringBuilder.append(product[i]);\n    }\n    stringBuilder.append(product[0]);\n    return stringBuilder.toString();\n}\n</code></pre><code>public String multiply(String num1, String num2) {\n    int len1 = num1.length();\n    int len2 = num2.length();\n    int[] product = new int[len1 + len2];\n    for (int i = len1 - 1; i &gt;= 0; i--) {\n        for (int j = len2 - 1; j &gt;= 0; j--) {\n            int index = len1 + len2 - i - j - 2;\n            product[index] += (num1.charAt(i) - '0') * (num2.charAt(j) - '0');\n            product[index + 1] += product[index] / 10;\n            product[index] %= 10;\n        }\n    }\n    StringBuilder stringBuilder = new StringBuilder();\n    for (int i = product.length - 1; i &gt; 0; i--) {\n        if (stringBuilder.length() == 0 &amp;&amp; product[i] == 0)\n            continue;\n        stringBuilder.append(product[i]);\n    }\n    stringBuilder.append(product[0]);\n    return stringBuilder.toString();\n}\n</code>", "votes": {"down": "0", "up": "17"}, "meta": {"author": "tusizi", "catagory": "Multiply Strings", "author_score": "20,650", "time": "2015-03-25T13:02:46+0000"}, "comments": [{"content": "<p>The last for loop with stringbuilder is a reversal...</p>", "votes": null, "meta": {"author": "BeaverNation", "author_score": "660", "time": "2015-05-25T23:33:13+0000"}}]}, "answers": [], "title": "Clear JAVA solution without reversal"}, {"question": {"content": "<pre><code>public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {\n    Arrays.sort(candidates);\n    Stack&lt;ArrayList&lt;Integer&gt;&gt; stack = new Stack&lt;ArrayList&lt;Integer&gt;&gt;();\n    Stack&lt;Integer&gt; sum = new Stack&lt;Integer&gt;();\n    Stack&lt;Integer&gt; start = new Stack&lt;Integer&gt;();\n    stack.push(new ArrayList&lt;Integer&gt;());\n    sum.push(0);\n    start.push(-1);\n    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    while (!stack.isEmpty()) {\n        List&lt;Integer&gt; res = stack.pop();\n        int total = sum.pop();\n        int begin = start.pop();\n        if (total == target)\n            result.add(res);\n        else {\n            for (int i = begin + 1; i &lt; candidates.length; i++) {\n                if (i &gt; begin + 1 &amp;&amp; candidates[i] == candidates[i - 1])\n                    continue;\n                int t = total + candidates[i];\n                if (t &gt; target)\n                    break;\n                ArrayList&lt;Integer&gt; r = new ArrayList&lt;Integer&gt;(res);\n                r.add(candidates[i]);\n                stack.push(r);\n                sum.push(t);\n                start.push(i);\n            }\n        }\n    }\n    return result;\n}\n</code></pre><code>public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {\n    Arrays.sort(candidates);\n    Stack&lt;ArrayList&lt;Integer&gt;&gt; stack = new Stack&lt;ArrayList&lt;Integer&gt;&gt;();\n    Stack&lt;Integer&gt; sum = new Stack&lt;Integer&gt;();\n    Stack&lt;Integer&gt; start = new Stack&lt;Integer&gt;();\n    stack.push(new ArrayList&lt;Integer&gt;());\n    sum.push(0);\n    start.push(-1);\n    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    while (!stack.isEmpty()) {\n        List&lt;Integer&gt; res = stack.pop();\n        int total = sum.pop();\n        int begin = start.pop();\n        if (total == target)\n            result.add(res);\n        else {\n            for (int i = begin + 1; i &lt; candidates.length; i++) {\n                if (i &gt; begin + 1 &amp;&amp; candidates[i] == candidates[i - 1])\n                    continue;\n                int t = total + candidates[i];\n                if (t &gt; target)\n                    break;\n                ArrayList&lt;Integer&gt; r = new ArrayList&lt;Integer&gt;(res);\n                r.add(candidates[i]);\n                stack.push(r);\n                sum.push(t);\n                start.push(i);\n            }\n        }\n    }\n    return result;\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Combination Sum II", "author_score": "20,650", "time": "2015-03-25T10:32:04+0000"}}, "answers": [], "title": "Simple JAVA solution based on Combination Sum"}, {"question": {"content": "<pre><code>class Solution:\n# @param candidates, a list of integers\n# @param target, integer\n# @return a list of lists of integers\ndef combinationSum(self, candidates, target):\n    candidates.sort()\n    stack = [(0, 0, [])]\n    result = []\n    while stack:\n        total, start, res = stack.pop()\n        if total == target:\n            result.append(res)\n        for n in range(start, len(candidates)):\n            t = total + candidates[n]\n            if t &gt; target:\n                break\n            stack.append((t, n, res + [candidates[n]]))\n    return result\n</code></pre><code>class Solution:\n# @param candidates, a list of integers\n# @param target, integer\n# @return a list of lists of integers\ndef combinationSum(self, candidates, target):\n    candidates.sort()\n    stack = [(0, 0, [])]\n    result = []\n    while stack:\n        total, start, res = stack.pop()\n        if total == target:\n            result.append(res)\n        for n in range(start, len(candidates)):\n            t = total + candidates[n]\n            if t &gt; target:\n                break\n            stack.append((t, n, res + [candidates[n]]))\n    return result\n</code><p>JAVA</p><pre><code>public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {\n    Arrays.sort(candidates);\n    Stack&lt;ArrayList&lt;Integer&gt;&gt; stack = new Stack&lt;ArrayList&lt;Integer&gt;&gt;();\n    Stack&lt;Integer&gt; sum = new Stack&lt;Integer&gt;();\n    Stack&lt;Integer&gt; start = new Stack&lt;Integer&gt;();\n    stack.push(new ArrayList&lt;Integer&gt;());\n    sum.push(0);\n    start.push(0);\n    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    while (!stack.isEmpty()) {\n        List&lt;Integer&gt; res = stack.pop();\n        int total = sum.pop();\n        int begin = start.pop();\n        if (total == target)\n            result.add(res);\n        else {\n            for (int i = begin; i &lt; candidates.length; i++) {\n                int t = total + candidates[i];\n                if (t &gt; target)\n                    break;\n                ArrayList&lt;Integer&gt; r = new ArrayList&lt;Integer&gt;(res);\n                r.add(candidates[i]);\n                stack.push(r);\n                sum.push(t);\n                start.push(i);\n            }\n        }\n    }\n    return result;\n}\n</code></pre><code>public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {\n    Arrays.sort(candidates);\n    Stack&lt;ArrayList&lt;Integer&gt;&gt; stack = new Stack&lt;ArrayList&lt;Integer&gt;&gt;();\n    Stack&lt;Integer&gt; sum = new Stack&lt;Integer&gt;();\n    Stack&lt;Integer&gt; start = new Stack&lt;Integer&gt;();\n    stack.push(new ArrayList&lt;Integer&gt;());\n    sum.push(0);\n    start.push(0);\n    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    while (!stack.isEmpty()) {\n        List&lt;Integer&gt; res = stack.pop();\n        int total = sum.pop();\n        int begin = start.pop();\n        if (total == target)\n            result.add(res);\n        else {\n            for (int i = begin; i &lt; candidates.length; i++) {\n                int t = total + candidates[i];\n                if (t &gt; target)\n                    break;\n                ArrayList&lt;Integer&gt; r = new ArrayList&lt;Integer&gt;(res);\n                r.add(candidates[i]);\n                stack.push(r);\n                sum.push(t);\n                start.push(i);\n            }\n        }\n    }\n    return result;\n}\n</code>", "votes": {"down": "0", "up": "3"}, "meta": {"author": "tusizi", "catagory": "Combination Sum", "author_score": "20,650", "time": "2015-03-24T15:15:53+0000"}}, "answers": [], "title": "Simple and fast DFS solution, python AC 98ms"}, {"question": {"content": "<pre><code>public int searchInsert(int[] A, int target) {\n    int start = 0;\n    int end = A.length - 1;\n    while (start &lt; end) {\n        int mid = start + (end - start) / 2;\n        if (target - 0.5 &lt; A[mid])\n            end = mid;\n        else\n            start = mid + 1;\n    }\n    return A[start] &gt;= target ? start : A.length;\n}\n</code></pre><code>public int searchInsert(int[] A, int target) {\n    int start = 0;\n    int end = A.length - 1;\n    while (start &lt; end) {\n        int mid = start + (end - start) / 2;\n        if (target - 0.5 &lt; A[mid])\n            end = mid;\n        else\n            start = mid + 1;\n    }\n    return A[start] &gt;= target ? start : A.length;\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Search Insert Position", "author_score": "20,650", "time": "2015-03-24T14:01:57+0000"}}, "answers": [], "title": "Search for the position target-0.5, share my short JAVA solution"}, {"question": {"content": "<pre><code>public ListNode swapPairs(ListNode head) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode current = dummy;\n    while (current.next != null &amp;&amp; current.next.next != null) {\n        ListNode first = current.next;\n        ListNode second = current.next.next;\n        first.next = second.next;\n        current.next = second;\n        current.next.next = first;\n        current = current.next.next;\n    }\n    return dummy.next;\n}\n</code></pre><code>public ListNode swapPairs(ListNode head) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode current = dummy;\n    while (current.next != null &amp;&amp; current.next.next != null) {\n        ListNode first = current.next;\n        ListNode second = current.next.next;\n        first.next = second.next;\n        current.next = second;\n        current.next.next = first;\n        current = current.next.next;\n    }\n    return dummy.next;\n}\n</code>", "votes": {"down": "0", "up": "5"}, "meta": {"author": "tusizi", "catagory": "Swap Nodes in Pairs", "author_score": "20,650", "time": "2015-03-23T12:22:17+0000"}, "comments": [{"content": "<p>The use of dummy node is excellent, thanks!</p>", "votes": null, "meta": {"author": "iziang", "author_score": "5,250", "time": "2015-04-12T09:05:40+0000"}}, {"content": "<p>great. I handle the first two specially. My solution is not beautiful.</p>", "votes": null, "meta": {"author": "lightmanliu", "author_score": "1,220", "time": "2015-04-18T16:20:06+0000"}}]}, "answers": [], "title": "My simple JAVA solution for share"}, {"question": {"content": "<pre><code>public List&lt;String&gt; generateParenthesis(int n) {\n    List&lt;String&gt; result = new ArrayList&lt;String&gt;();\n    Stack&lt;String&gt; stack = new Stack&lt;String&gt;();\n    Stack&lt;int[]&gt; generate = new Stack&lt;int[]&gt;();\n    stack.push(\"\");\n    generate.push(new int[]{n, 0});\n    while (!stack.isEmpty()) {\n        String s = stack.pop();\n        int open = generate.peek()[0];\n        int close = generate.pop()[1];\n        if (open == 0 &amp;&amp; close == 0)\n            result.add(s);\n        if (open &gt; 0) {\n            stack.push(s + \"(\");\n            generate.push(new int[]{open - 1, close + 1});\n        }\n        if (close &gt; 0) {\n            stack.push(s + \")\");\n            generate.push(new int[]{open, close - 1});\n        }\n    }\n    return result;\n}\n</code></pre><code>public List&lt;String&gt; generateParenthesis(int n) {\n    List&lt;String&gt; result = new ArrayList&lt;String&gt;();\n    Stack&lt;String&gt; stack = new Stack&lt;String&gt;();\n    Stack&lt;int[]&gt; generate = new Stack&lt;int[]&gt;();\n    stack.push(\"\");\n    generate.push(new int[]{n, 0});\n    while (!stack.isEmpty()) {\n        String s = stack.pop();\n        int open = generate.peek()[0];\n        int close = generate.pop()[1];\n        if (open == 0 &amp;&amp; close == 0)\n            result.add(s);\n        if (open &gt; 0) {\n            stack.push(s + \"(\");\n            generate.push(new int[]{open - 1, close + 1});\n        }\n        if (close &gt; 0) {\n            stack.push(s + \")\");\n            generate.push(new int[]{open, close - 1});\n        }\n    }\n    return result;\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Generate Parentheses", "author_score": "20,650", "time": "2015-03-22T16:00:25+0000"}}, "answers": [], "title": "JAVA DFS solution"}, {"question": {"content": "<pre><code>public class Solution {\n// you need to treat n as an unsigned value\npublic int hammingWeight(int n) {\n    int count = 0;\n    for (; n != 0; n &gt;&gt;&gt;= 1)\n        count += 1 &amp; n;\n\n    return count;\n}\n}\n</code></pre><code>public class Solution {\n// you need to treat n as an unsigned value\npublic int hammingWeight(int n) {\n    int count = 0;\n    for (; n != 0; n &gt;&gt;&gt;= 1)\n        count += 1 &amp; n;\n\n    return count;\n}\n}\n</code><p>Bit Hack</p><pre><code>public class Solution {\n// you need to treat n as an unsigned value\npublic int hammingWeight(int n) {\n    int count = 0;\n    for (; n != 0; n &amp;= n-1){\n        count++;\n    }\n    return count;\n}\n}\n</code></pre><code>public class Solution {\n// you need to treat n as an unsigned value\npublic int hammingWeight(int n) {\n    int count = 0;\n    for (; n != 0; n &amp;= n-1){\n        count++;\n    }\n    return count;\n}\n}\n</code><p>Python one line</p><pre><code>class Solution:\n# @param n, an integer\n# @return an integer\ndef hammingWeight(self, n):\n    return bin(n).count('1')\n</code></pre><code>class Solution:\n# @param n, an integer\n# @return an integer\ndef hammingWeight(self, n):\n    return bin(n).count('1')\n</code>", "votes": {"down": "0", "up": "4"}, "meta": {"author": "tusizi", "catagory": "Number of 1 Bits", "author_score": "20,650", "time": "2015-03-18T13:55:28+0000"}}, "answers": [{"content": "<p>what is the difference between &gt;&gt;&gt;= and &gt;&gt;=   ?</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "ran7", "author_score": "110", "time": "2015-03-18T15:48:36+0000"}, "comments": [{"content": "<p>The unsigned right shift operator \"&gt;&gt;&gt;\" shifts a zero into the leftmost position, while the leftmost position after \"&gt;&gt;\" depends on sign extension. -- from documentation</p>", "votes": null, "meta": {"author": "bearkino", "author_score": "100", "time": "2015-03-29T06:42:17+0000"}}]}], "title": "My simple Python and JAVA solution for share"}, {"question": {"content": "<pre><code>class Solution:\n# @param s, a string\n# @return an integer\ndef titleToNumber(self, s):\n    res = 0\n    for i in s:\n        res = 26*res + int(i, 36) - 9\n    return res\n</code></pre><code>class Solution:\n# @param s, a string\n# @return an integer\ndef titleToNumber(self, s):\n    res = 0\n    for i in s:\n        res = 26*res + int(i, 36) - 9\n    return res\n</code><p>One line</p><pre><code>class Solution:\n# @param s, a string\n# @return an integer\ndef titleToNumber(self, s):\n    return sum(26**n*(int(i, 36)-9) for n, i in enumerate(s[::-1]))\n</code></pre><code>class Solution:\n# @param s, a string\n# @return an integer\ndef titleToNumber(self, s):\n    return sum(26**n*(int(i, 36)-9) for n, i in enumerate(s[::-1]))\n</code><p>JAVA</p><pre><code>    public int titleToNumber(String s) {\n    int res = 0;\n    for (char c: s.toCharArray())\n        res = 26*res + c-'A'+1;\n\n    return res;\n    }\n</code></pre><code>    public int titleToNumber(String s) {\n    int res = 0;\n    for (char c: s.toCharArray())\n        res = 26*res + c-'A'+1;\n\n    return res;\n    }\n</code>", "votes": {"down": "0", "up": "3"}, "meta": {"author": "tusizi", "catagory": "Excel Sheet Column Number", "author_score": "20,650", "time": "2015-03-17T12:26:42+0000"}}, "answers": [], "title": "Share my python solution use int(i, base=36) and simple JAVA solution."}, {"question": {"content": "<pre><code>public class Solution {\nprivate boolean result = true;\n\npublic boolean isBalanced(TreeNode root) {\n    maxDepth(root);\n    return result;\n}\n\npublic int maxDepth(TreeNode root) {\n    if (root == null)\n        return 0;\n    int l = maxDepth(root.left);\n    int r = maxDepth(root.right);\n    if (Math.abs(l - r) &gt; 1)\n        result = false;\n    return 1 + Math.max(l, r);\n}\n}\n</code></pre><code>public class Solution {\nprivate boolean result = true;\n\npublic boolean isBalanced(TreeNode root) {\n    maxDepth(root);\n    return result;\n}\n\npublic int maxDepth(TreeNode root) {\n    if (root == null)\n        return 0;\n    int l = maxDepth(root.left);\n    int r = maxDepth(root.right);\n    if (Math.abs(l - r) &gt; 1)\n        result = false;\n    return 1 + Math.max(l, r);\n}\n}\n</code>", "votes": {"down": "0", "up": "9"}, "meta": {"author": "tusizi", "catagory": "Balanced Binary Tree", "author_score": "20,650", "time": "2015-03-14T12:06:30+0000"}}, "answers": [{"content": "<p>A revision without using global value is following, but your solution is definitely better performed when running:</p><pre><code>    public class Solution {\n    public boolean isBalanced(TreeNode root) {\n        if (root == null)\n            return true;\n        if (Math.abs(height(root.left)-height(root.right)) &lt;= 1)\n            return (isBalanced(root.left) &amp;&amp; isBalanced(root.right));\n        return false;\n    }\n    public int height(TreeNode root) {\n        if (root == null)\n            return 0;\n        int left = height(root.left);\n        int right= height(root.right);\n        return (Math.max(left,right)+1);\n\n    }\n}\n</code></pre><code>    public class Solution {\n    public boolean isBalanced(TreeNode root) {\n        if (root == null)\n            return true;\n        if (Math.abs(height(root.left)-height(root.right)) &lt;= 1)\n            return (isBalanced(root.left) &amp;&amp; isBalanced(root.right));\n        return false;\n    }\n    public int height(TreeNode root) {\n        if (root == null)\n            return 0;\n        int left = height(root.left);\n        int right= height(root.right);\n        return (Math.max(left,right)+1);\n\n    }\n}\n</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "freddykyang", "author_score": "370", "time": "2015-04-22T02:24:39+0000"}, "comments": [{"content": "<p>your solution will do lots of useless searching.</p>", "votes": null, "meta": {"author": "dianren", "author_score": "70", "time": "2015-08-05T08:10:53+0000"}}]}, {"content": "<p>It would be better if you call that height instead of maxDepth.</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "freddykyang", "author_score": "370", "time": "2015-04-22T02:05:10+0000"}}], "title": "JAVA O(n) solution based on Maximum Depth of Binary Tree"}, {"question": {"content": "<pre><code>    public void merge(int A[], int m, int B[], int n) {\n    int write = m+n-1;\n    int readA = m-1;\n    int readB = n-1;\n    while (readB &gt;= 0){\n        if (readA == -1)\n            A[write--] = B[readB--];\n        else if (A[readA] &lt;= B[readB])\n            A[write--] = B[readB--];\n        else\n            A[write--] = A[readA--];\n    }\n}\n</code></pre><code>    public void merge(int A[], int m, int B[], int n) {\n    int write = m+n-1;\n    int readA = m-1;\n    int readB = n-1;\n    while (readB &gt;= 0){\n        if (readA == -1)\n            A[write--] = B[readB--];\n        else if (A[readA] &lt;= B[readB])\n            A[write--] = B[readB--];\n        else\n            A[write--] = A[readA--];\n    }\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Merge Sorted Array", "author_score": "20,650", "time": "2015-03-13T10:54:00+0000"}}, "answers": [], "title": "Clear java solution, read and write"}, {"question": {"content": "<pre><code>public class Solution {\npublic int reverse(int x) {\n    int sign = 1;\n    if (x &lt; 0){\n        sign = -1;\n        x = -x;\n    }\n    int ret = 0;\n    while (x &gt; 0){\n        if (ret &gt; 214748364)\n            return 0;\n        ret = ret*10 + x % 10;\n        x /= 10;\n    }\n    return sign*ret;\n}\n}\n</code></pre><code>public class Solution {\npublic int reverse(int x) {\n    int sign = 1;\n    if (x &lt; 0){\n        sign = -1;\n        x = -x;\n    }\n    int ret = 0;\n    while (x &gt; 0){\n        if (ret &gt; 214748364)\n            return 0;\n        ret = ret*10 + x % 10;\n        x /= 10;\n    }\n    return sign*ret;\n}\n}\n</code><p>if ret == 214748364</p><p>x /= 10 can only be 0 or 1</p><p>There's no overflow</p>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "tusizi", "catagory": "Reverse Integer", "author_score": "20,650", "time": "2015-03-08T08:19:37+0000"}, "comments": [{"content": "<p>I suggest to replacing 214748364 with Integer.MAX_VALUE/10</p>", "votes": null, "meta": {"author": "siyang3", "author_score": "10,310", "time": "2015-03-14T02:44:12+0000"}}]}, "answers": [{"content": "<p>Your code is the ideal code for this problem. However, I found out that for <code>x = Integer.MIN_VALUE</code>. <code>-x = Integer.MIN_VALUE</code>. And it happens that this case was skipped by <code>while(x &gt; 0)</code>. I think it's better to list it as an edge case. Updated code for reference.</p><code>x = Integer.MIN_VALUE</code><code>-x = Integer.MIN_VALUE</code><code>while(x &gt; 0)</code><pre><code>public class Solution {\n    public int reverse(int x) {\n        // edge case\n        if(x==Integer.MIN_VALUE) return 0;\n        // negative number, convert from positive\n        if(x &lt; 0) return -reverse(-x);\n\n        int y = 0;\n        while(x != 0){\n\n            // edge case, overflow\n            if(y &gt; Integer.MAX_VALUE/10) return 0;\n\n            y *= 10;\n            y += x%10;\n            x /= 10;\n        }\n        return y;\n    }\n}\n</code></pre><code>public class Solution {\n    public int reverse(int x) {\n        // edge case\n        if(x==Integer.MIN_VALUE) return 0;\n        // negative number, convert from positive\n        if(x &lt; 0) return -reverse(-x);\n\n        int y = 0;\n        while(x != 0){\n\n            // edge case, overflow\n            if(y &gt; Integer.MAX_VALUE/10) return 0;\n\n            y *= 10;\n            y += x%10;\n            x /= 10;\n        }\n        return y;\n    }\n}\n</code>", "votes": {"down": "0", "up": "2"}, "meta": {"author": "siyang3", "author_score": "10,310", "time": "2015-03-14T02:53:58+0000"}, "best_answer": true, "comments": [{"content": "<p>Yes , I didn't realise the edge case Integer.MIN_VALUE may overflow,</p><p>Thanks for your code review.</p>", "votes": null, "meta": {"author": "tusizi", "author_score": "20,650", "time": "2015-03-14T08:45:26+0000"}}]}], "title": "Java solution without long"}, {"question": {"content": "<p><a rel=\"nofollow\" href=\"https://oj.leetcode.com/discuss/18330/is-it-best-solution-with-o-n-o-1\">Here's his pretty solution</a></p><a rel=\"nofollow\" href=\"https://oj.leetcode.com/discuss/18330/is-it-best-solution-with-o-n-o-1\">Here's his pretty solution</a><pre><code>class Solution:\n# @param prices, a list of integer\n# @return an integer\ndef maxProfit(self, k, prices):\n    if k &gt;= len(prices)//2:\n        return sum(i-j for i, j in zip(prices[1:], prices[:-1]) if i-j &gt; 0)\n    hold, release = [float('-inf')]*(k+1), [0]*(k+1)\n    for p in prices:\n        for i in range(1, k+1):\n            release[i] = max(release[i], hold[i]+p)\n            hold[i] = max(hold[i], release[i-1]-p)\n    return release[k]\n</code></pre><code>class Solution:\n# @param prices, a list of integer\n# @return an integer\ndef maxProfit(self, k, prices):\n    if k &gt;= len(prices)//2:\n        return sum(i-j for i, j in zip(prices[1:], prices[:-1]) if i-j &gt; 0)\n    hold, release = [float('-inf')]*(k+1), [0]*(k+1)\n    for p in prices:\n        for i in range(1, k+1):\n            release[i] = max(release[i], hold[i]+p)\n            hold[i] = max(hold[i], release[i-1]-p)\n    return release[k]\n</code><p>It is easy to convert 2 to k times</p>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "tusizi", "catagory": "Best Time to Buy and Sell Stock IV", "author_score": "20,650", "time": "2015-03-07T20:35:44+0000"}, "comments": [{"content": "<p>Could you please explain the release[i] and hold[i] meaning here? why  \"hold[i] = max(hold[i], release[i-1]-p)\" ? Thank you!</p>", "votes": null, "meta": {"author": "UmassJin", "author_score": "250", "time": "2015-03-16T00:35:03+0000"}}, {"content": "<p>release[i] is one (dynamic) row of a 2D array (table) in dynamic programming. so is hold[i].</p><p>when I say \"dynamic\", I mean that this program is cunningly optimized to represent a 2D table by one row. therefore, release[i] have different meaning at different price p.</p><p>that being said, in a un-optimized version  of this solution (which i may paste later), the tables should look like the following release[p][i], hold[p][i].</p><p>release[p][i] stores the maximum net balance after selling at prices[p] in transaction i.\nhold[p][i] stores the maximum net balance after buying at prices[p] in transaction i.</p><p>if you still have questions, you may want to read more about Dynamic Programming and how tables are updated in DP.</p>", "votes": null, "meta": {"author": "darker_side", "author_score": "100", "time": "2015-04-18T00:47:00+0000"}}, {"content": "<p>Thanks a lot for the detailed explanation ! </p>", "votes": null, "meta": {"author": "UmassJin", "author_score": "250", "time": "2015-04-18T03:16:49+0000"}}]}, "answers": [], "title": "Short python solution from weijiac's Best Time to Buy and Sell Stock III"}, {"question": {"content": "<pre><code>class Solution:\n# @param prices, a list of integer\n# @return an integer\ndef maxProfit(self, prices):\n    profit = [0]*len(prices)\n    low, high = float('inf'), float('-inf')\n    max_profit = res = 0\n    for n, p in enumerate(prices):\n        low = min(p, low)\n        max_profit = max(max_profit, p-low)\n        profit[n] = max_profit\n    max_profit = 0\n    for n, p in reversed(list(enumerate(prices))):\n        high = max(p, high)\n        max_profit = max(max_profit, high-p)\n        res = max(res, max_profit+profit[n])\n    return res\n</code></pre><code>class Solution:\n# @param prices, a list of integer\n# @return an integer\ndef maxProfit(self, prices):\n    profit = [0]*len(prices)\n    low, high = float('inf'), float('-inf')\n    max_profit = res = 0\n    for n, p in enumerate(prices):\n        low = min(p, low)\n        max_profit = max(max_profit, p-low)\n        profit[n] = max_profit\n    max_profit = 0\n    for n, p in reversed(list(enumerate(prices))):\n        high = max(p, high)\n        max_profit = max(max_profit, high-p)\n        res = max(res, max_profit+profit[n])\n    return res\n</code><p>scan from left, profit[n] means from 0-n day the max_profit we can get</p><p>scan from right, profit[n] means from n-last day the max_profit we can get</p><p>add left and right, find the result</p>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "tusizi", "catagory": "Best Time to Buy and Sell Stock III", "author_score": "20,650", "time": "2015-03-07T17:50:12+0000"}}, "answers": [{"content": "<p>There is no such thing O(2n). You can count the exact loops though. Somehow, I don't like this code since it is pythonic for being pythonic. esp. reversed(list(enumerate(prices))) is horrible as you can actually do a loop on index generator with xrange (or range in python 3).</p>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "hu.cao1", "author_score": "2,370", "time": "2015-03-22T03:12:10+0000"}}], "title": "A simple python solution, O(2n) time, O(n) space"}, {"question": {"content": "<pre><code>class Solution:\n# @param n, an integer\n# @return an integer\ndef reverseBits(self, n):\n    return int('{:0&gt;32b}'.format(n)[::-1], 2)\n</code></pre><code>class Solution:\n# @param n, an integer\n# @return an integer\ndef reverseBits(self, n):\n    return int('{:0&gt;32b}'.format(n)[::-1], 2)\n</code><p>straight forward</p><pre><code>class Solution:\n# @param n, an integer\n# @return an integer\ndef reverseBits(self, n):\n    res = 0\n    for i in range(32):\n        res += 1 &amp; n\n        if i == 31:\n            return res\n        n &gt;&gt;= 1\n        res &lt;&lt;= 1\n</code></pre><code>class Solution:\n# @param n, an integer\n# @return an integer\ndef reverseBits(self, n):\n    res = 0\n    for i in range(32):\n        res += 1 &amp; n\n        if i == 31:\n            return res\n        n &gt;&gt;= 1\n        res &lt;&lt;= 1\n</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "tusizi", "catagory": "Reverse Bits", "author_score": "20,650", "time": "2015-03-07T14:40:16+0000"}, "comments": [{"content": "<p>In your second solution, is it really faster to include the condition \"if i == 31\" in the loop to avoid the last 2 instructions in the ultimate loop iteration?</p>", "votes": null, "meta": {"author": "Digma", "author_score": "100", "time": "2015-07-03T08:11:27+0000"}}]}, "answers": [{"content": "<p>the First is cool  ,what is the awesome feature in python (     \"{:&gt;32b}\u201c.format(n)     )</p>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "Xu-Zhang", "author_score": "230", "time": "2015-03-08T07:07:24+0000"}, "comments": [{"content": "<p>please see  https://docs.python.org/3/library/string.html#format-specification-mini-language</p><p>this can also write int('{:032b}'.format(n)[::-1], 2)</p>", "votes": null, "meta": {"author": "tusizi", "author_score": "20,650", "time": "2015-03-08T08:36:04+0000"}}, {"content": "<p>I also have seen usage of '{0:032b}'.format(n), is it the same as '{:032b}'.format(n)?</p>", "votes": null, "meta": {"author": "yan.jiang.980", "author_score": "100", "time": "2015-03-09T16:05:04+0000"}}]}], "title": "Python string format"}, {"question": {"content": "<p>common BFS</p><pre><code>class Solution:\n# @param root, a tree link node\n# @return nothing\ndef connect(self, root):\n    if not root:\n        return\n    queue, level = collections.deque([root]), collections.deque()\n    while queue:\n        node = queue.popleft()\n        if node.left:\n            level.append(node.left)\n        if node.right:\n            level.append(node.right)\n        node.next = queue[0] if queue else None\n        if not queue and level:\n            queue, level = level, queue\n</code></pre><code>class Solution:\n# @param root, a tree link node\n# @return nothing\ndef connect(self, root):\n    if not root:\n        return\n    queue, level = collections.deque([root]), collections.deque()\n    while queue:\n        node = queue.popleft()\n        if node.left:\n            level.append(node.left)\n        if node.right:\n            level.append(node.right)\n        node.next = queue[0] if queue else None\n        if not queue and level:\n            queue, level = level, queue\n</code><p>O(1) space</p><pre><code>class Solution:\n# @param root, a tree link node\n# @return nothing\ndef connect(self, root):\n    queue, level, curr = root, None, None\n    while queue:\n        if queue.left:\n            if not level:\n                level = curr = queue.left\n            else:\n                curr.next = queue.left\n                curr = curr.next\n        if queue.right:\n            if not level:\n                level = curr = queue.right\n            else:\n                curr.next = queue.right\n                curr = curr.next\n        queue = queue.next\n        if not queue and level:\n            queue, level, curr = level, None, None\n</code></pre><code>class Solution:\n# @param root, a tree link node\n# @return nothing\ndef connect(self, root):\n    queue, level, curr = root, None, None\n    while queue:\n        if queue.left:\n            if not level:\n                level = curr = queue.left\n            else:\n                curr.next = queue.left\n                curr = curr.next\n        if queue.right:\n            if not level:\n                level = curr = queue.right\n            else:\n                curr.next = queue.right\n                curr = curr.next\n        queue = queue.next\n        if not queue and level:\n            queue, level, curr = level, None, None\n</code><p>Use a fake head can save a few lines</p>", "votes": {"down": "0", "up": "4"}, "meta": {"author": "tusizi", "catagory": "Populating Next Right Pointers in Each Node II", "author_score": "20,650", "time": "2015-03-06T18:08:27+0000"}}, "answers": [{"content": "<p>Good answer, while the first BFS case can also be written as:</p><pre><code># BFS with queue\ndef connect(self, root):\n    if not root:\n        return \n    queue, nextLevel = [root], []   # queue records the previous level\n    while queue:\n        curr = queue.pop(0)\n        if curr.left:\n            nextLevel.append(curr.left)\n        if curr.right:\n            nextLevel.append(curr.right)\n        if queue:\n            curr.next = queue[0]\n        if not queue and nextLevel:\n            queue, nextLevel = nextLevel, queue\n</code></pre><code># BFS with queue\ndef connect(self, root):\n    if not root:\n        return \n    queue, nextLevel = [root], []   # queue records the previous level\n    while queue:\n        curr = queue.pop(0)\n        if curr.left:\n            nextLevel.append(curr.left)\n        if curr.right:\n            nextLevel.append(curr.right)\n        if queue:\n            curr.next = queue[0]\n        if not queue and nextLevel:\n            queue, nextLevel = nextLevel, queue\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "caikehe", "author_score": "8,580", "time": "2015-07-11T08:23:32+0000"}}], "title": "Just convert common BFS solution to O(1)  space, a simple python code"}, {"question": {"content": "<pre><code>class Solution:\n# @param root, a tree node\n# @return a tree node\ndef recoverTree(self, root):\n    it = self.isValidBST(root)\n    a, b = next(it)\n    c = next(it, None)\n    if c:\n        _, c = c\n        a.val, c.val = c.val, a.val\n    else:\n        a.val, b.val = b.val, a.val\n    return root\n\ndef isValidBST(self, root):\n    pre, cur, stack = None, root, []\n    while stack or cur:\n        while cur:\n            stack.append(cur)\n            cur = cur.left\n        s = stack.pop()\n        if pre and s.val &lt;= pre.val:\n            yield pre, s\n        pre, cur = s, s.right\n</code></pre><code>class Solution:\n# @param root, a tree node\n# @return a tree node\ndef recoverTree(self, root):\n    it = self.isValidBST(root)\n    a, b = next(it)\n    c = next(it, None)\n    if c:\n        _, c = c\n        a.val, c.val = c.val, a.val\n    else:\n        a.val, b.val = b.val, a.val\n    return root\n\ndef isValidBST(self, root):\n    pre, cur, stack = None, root, []\n    while stack or cur:\n        while cur:\n            stack.append(cur)\n            cur = cur.left\n        s = stack.pop()\n        if pre and s.val &lt;= pre.val:\n            yield pre, s\n        pre, cur = s, s.right\n</code><p>This is a simple O(n) space solution.</p><p>Add Java solution</p><pre><code>TreeNode prev = null;\nLinkedList&lt;TreeNode&gt; result = new LinkedList&lt;TreeNode&gt;();\n\npublic void recoverTree(TreeNode root) {\n    isValidBST(root);\n    TreeNode first = result.poll();\n    TreeNode last = result.pollLast();\n    int temp = first.val;\n    first.val = last.val;\n    last.val = temp;\n}\n\nprivate void isValidBST(TreeNode root) {\n    if (root == null)\n        return;\n    isValidBST(root.left);\n    if (prev != null &amp;&amp; root.val &lt; prev.val) {\n        result.add(prev);\n        result.add(root);\n    }\n    prev = root;\n    isValidBST(root.right);\n}\n</code></pre><code>TreeNode prev = null;\nLinkedList&lt;TreeNode&gt; result = new LinkedList&lt;TreeNode&gt;();\n\npublic void recoverTree(TreeNode root) {\n    isValidBST(root);\n    TreeNode first = result.poll();\n    TreeNode last = result.pollLast();\n    int temp = first.val;\n    first.val = last.val;\n    last.val = temp;\n}\n\nprivate void isValidBST(TreeNode root) {\n    if (root == null)\n        return;\n    isValidBST(root.left);\n    if (prev != null &amp;&amp; root.val &lt; prev.val) {\n        result.add(prev);\n        result.add(root);\n    }\n    prev = root;\n    isValidBST(root.right);\n}\n</code>", "votes": {"down": "0", "up": "3"}, "meta": {"author": "tusizi", "catagory": "Recover Binary Search Tree", "author_score": "20,650", "time": "2015-03-06T16:17:01+0000"}, "comments": [{"content": "<p>It's a great solution! It helped me understand python's way of recursion. There is only a minor mistake. Since the question does not require any return value, you should remove the \"return root\" in recovertree().</p>", "votes": null, "meta": {"author": "Sowhat007", "author_score": "140", "time": "2015-03-20T15:53:43+0000"}}]}, "answers": [], "title": "Python Inorder Traversal solution based on Validate Binary Search Tree"}, {"question": {"content": "<pre><code>class Solution:\n# @return a boolean\ndef isInterleave(self, s1, s2, s3):\n    n, m = len(s1), len(s2)\n    if n+m != len(s3):\n        return False\n    stack, visited = [(0, 0)], set()\n    while stack:\n        y, x = stack.pop()\n        if y+x == len(s3):\n            return True\n        if x+1 &lt;= n and s1[x] == s3[y+x] and (y, x+1) not in visited:\n            visited.add((y, x+1))\n            stack.append((y, x+1))\n        if y+1 &lt;= m and s2[y] == s3[y+x] and (y+1, x) not in visited:\n            visited.add((y+1, x))\n            stack.append((y+1, x))\n    return False\n</code></pre><code>class Solution:\n# @return a boolean\ndef isInterleave(self, s1, s2, s3):\n    n, m = len(s1), len(s2)\n    if n+m != len(s3):\n        return False\n    stack, visited = [(0, 0)], set()\n    while stack:\n        y, x = stack.pop()\n        if y+x == len(s3):\n            return True\n        if x+1 &lt;= n and s1[x] == s3[y+x] and (y, x+1) not in visited:\n            visited.add((y, x+1))\n            stack.append((y, x+1))\n        if y+1 &lt;= m and s2[y] == s3[y+x] and (y+1, x) not in visited:\n            visited.add((y+1, x))\n            stack.append((y+1, x))\n    return False\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Interleaving String", "author_score": "20,650", "time": "2015-03-06T14:53:00+0000"}}, "answers": [], "title": "Python DFS solution from grapeot's 8ms BFS solution"}, {"question": {"content": "<pre><code>class Solution:\n# @return a boolean\ndef isScramble(self, s1, s2):\n    n, m = len(s1), len(s2)\n    if n != m or sorted(s1) != sorted(s2):\n        return False\n    if n &lt; 4 or s1 == s2:\n        return True\n    f = self.isScramble\n    for i in range(1, n):\n        if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \\\n           f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):\n            return True\n    return False\n</code></pre><code>class Solution:\n# @return a boolean\ndef isScramble(self, s1, s2):\n    n, m = len(s1), len(s2)\n    if n != m or sorted(s1) != sorted(s2):\n        return False\n    if n &lt; 4 or s1 == s2:\n        return True\n    f = self.isScramble\n    for i in range(1, n):\n        if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \\\n           f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]):\n            return True\n    return False\n</code>", "votes": {"down": "0", "up": "8"}, "meta": {"author": "tusizi", "catagory": "Scramble String", "author_score": "20,650", "time": "2015-03-06T14:00:58+0000"}}, "answers": [{"content": "<p>Nice solution. Although it does not use memoization, it still runs very fast. But I wonder if some extreme test case may lead to a slow runtime of this code and make it TLE? Because it seems to me that this code still runs in NP time according to big-o notation. </p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "xiangzhou.chen.5", "author_score": "1,000", "time": "2015-08-13T20:31:30+0000"}}], "title": "Python recursive solution"}, {"question": {"content": "<pre><code>class Solution:\n# @param matrix, a list of lists of 1 length string\n# @return an integer\ndef maximalRectangle(self, matrix):\n    if not matrix:\n        return 0\n    h, w = len(matrix), len(matrix[0])\n    m = [[0]*w for _ in range(h)]\n    for j in range(h):\n        for i in range(w):\n            if matrix[j][i] == '1':\n                m[j][i] = m[j-1][i] + 1\n    return max(self.largestRectangleArea(row) for row in m)\n\ndef largestRectangleArea(self, height):\n    height.append(0)\n    stack, size = [], 0\n    for i in range(len(height)):\n        while stack and height[stack[-1]] &gt; height[i]:\n            h = height[stack.pop()]\n            w = i if not stack else i-stack[-1]-1\n            size = max(size, h*w)\n        stack.append(i)\n    return size\n</code></pre><code>class Solution:\n# @param matrix, a list of lists of 1 length string\n# @return an integer\ndef maximalRectangle(self, matrix):\n    if not matrix:\n        return 0\n    h, w = len(matrix), len(matrix[0])\n    m = [[0]*w for _ in range(h)]\n    for j in range(h):\n        for i in range(w):\n            if matrix[j][i] == '1':\n                m[j][i] = m[j-1][i] + 1\n    return max(self.largestRectangleArea(row) for row in m)\n\ndef largestRectangleArea(self, height):\n    height.append(0)\n    stack, size = [], 0\n    for i in range(len(height)):\n        while stack and height[stack[-1]] &gt; height[i]:\n            h = height[stack.pop()]\n            w = i if not stack else i-stack[-1]-1\n            size = max(size, h*w)\n        stack.append(i)\n    return size\n</code><p>m is every row height, it is easy to convert this to Largest Rectangle in Histogram</p>", "votes": {"down": "0", "up": "9"}, "meta": {"author": "tusizi", "catagory": "Maximal Rectangle", "author_score": "20,650", "time": "2015-03-05T17:07:37+0000"}, "comments": [{"content": "<p>very creative way of using list comprehension in the max, thanks for sharing. though you could actually just maintain 1 row for each iteration instead of h rows. </p>", "votes": null, "meta": {"author": "icrtiou", "author_score": "680", "time": "2015-05-16T18:34:32+0000"}}, {"content": "<p>yeah, very smart</p>", "votes": null, "meta": {"author": "phycept", "author_score": "110", "time": "2015-05-18T11:01:27+0000"}}, {"content": "<p>m[j][i] = m[j-1][i] + 1 will error, you need an \"if\"</p>", "votes": null, "meta": {"author": "molting", "author_score": "100", "time": "2015-07-06T03:07:58+0000"}}]}, "answers": [], "title": "Pyrhon O(n^2) solution based on Largest Rectangle in Histogram"}, {"question": {"content": "<pre><code>class Solution:\n# @return a string\ndef minWindow(self, s, t):\n    window = collections.Counter(t)  # if window is empty, we find a window\n    extra = {char: 0 for char in t}  # use extra to check char if in t and count extra letters in window\n    i, start, end = 0, 0, len(s)+1  # window size is end-start, if end == len(s)+1, there is no window in s\n    for j, char in enumerate(s):\n        if char in extra:\n            if char in window:\n                window[char] -= 1  # we find a char in window\n                if window[char] == 0:  # we find all this char in window\n                    del window[char]\n            else:\n                extra[char] += 1   # we find extra char in this window\n            while not window:  # we find a window\n                char = s[i]  # scan from i\n                i += 1\n                if char not in extra:\n                    continue  # char not in this window, window size can be smaller\n                elif extra[char]:  # extra[char] &gt; 0\n                    extra[char] -= 1  # window size can be smaller\n                elif not extra[char]:  # extra[char] == 0 the window can't be smaller\n                    window[char] += 1  # we restart to find a new window\n                    if j - i + 2 &lt; end - start: # this window size is j+1 - (i-1)\n                        start, end = i-1, j+1\n    return '' if end == len(s)+1 else s[start:end]\n</code></pre><code>class Solution:\n# @return a string\ndef minWindow(self, s, t):\n    window = collections.Counter(t)  # if window is empty, we find a window\n    extra = {char: 0 for char in t}  # use extra to check char if in t and count extra letters in window\n    i, start, end = 0, 0, len(s)+1  # window size is end-start, if end == len(s)+1, there is no window in s\n    for j, char in enumerate(s):\n        if char in extra:\n            if char in window:\n                window[char] -= 1  # we find a char in window\n                if window[char] == 0:  # we find all this char in window\n                    del window[char]\n            else:\n                extra[char] += 1   # we find extra char in this window\n            while not window:  # we find a window\n                char = s[i]  # scan from i\n                i += 1\n                if char not in extra:\n                    continue  # char not in this window, window size can be smaller\n                elif extra[char]:  # extra[char] &gt; 0\n                    extra[char] -= 1  # window size can be smaller\n                elif not extra[char]:  # extra[char] == 0 the window can't be smaller\n                    window[char] += 1  # we restart to find a new window\n                    if j - i + 2 &lt; end - start: # this window size is j+1 - (i-1)\n                        start, end = i-1, j+1\n    return '' if end == len(s)+1 else s[start:end]\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Minimum Window Substring", "author_score": "20,650", "time": "2015-03-04T21:32:10+0000"}}, "answers": [], "title": "An easy understanding python O(2n) solution use two Counters with comments"}, {"question": {"content": "<pre><code>class Solution:\n# @param num, a list of integer\n# @return an integer\ndef maximumGap(self, num):\n    if len(num) &lt; 2 or min(num) == max(num):\n        return 0\n    a, b = min(num), max(num)\n    size = math.ceil((b-a)/(len(num)-1))\n    bucket = [[None, None] for _ in range((b-a)//size+1)]\n    for n in num:\n        b = bucket[(n-a)//size]\n        b[0] = n if b[0] is None else min(b[0], n)\n        b[1] = n if b[1] is None else max(b[1], n)\n    bucket = [b for b in bucket if b[0] is not None]\n    return max(bucket[i][0]-bucket[i-1][1] for i in range(1, len(bucket)))\n</code></pre><code>class Solution:\n# @param num, a list of integer\n# @return an integer\ndef maximumGap(self, num):\n    if len(num) &lt; 2 or min(num) == max(num):\n        return 0\n    a, b = min(num), max(num)\n    size = math.ceil((b-a)/(len(num)-1))\n    bucket = [[None, None] for _ in range((b-a)//size+1)]\n    for n in num:\n        b = bucket[(n-a)//size]\n        b[0] = n if b[0] is None else min(b[0], n)\n        b[1] = n if b[1] is None else max(b[1], n)\n    bucket = [b for b in bucket if b[0] is not None]\n    return max(bucket[i][0]-bucket[i-1][1] for i in range(1, len(bucket)))\n</code><p>The python version is 3.4, for 2.7 version rewrite the size</p>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "tusizi", "catagory": "Maximum Gap", "author_score": "20,650", "time": "2015-03-04T09:21:27+0000"}}, "answers": [], "title": "Python bucket sort from official solution"}, {"question": {"content": "<pre><code>class Solution:\n# @param head, a RandomListNode\n# @return a RandomListNode\ndef copyRandomList(self, head):\n    dic = dict()\n    m = n = head\n    while m:\n        dic[m] = RandomListNode(m.label)\n        m = m.next\n    while n:\n        dic[n].next = dic.get(n.next)\n        dic[n].random = dic.get(n.random)\n        n = n.next\n    return dic.get(head)\n</code></pre><code>class Solution:\n# @param head, a RandomListNode\n# @return a RandomListNode\ndef copyRandomList(self, head):\n    dic = dict()\n    m = n = head\n    while m:\n        dic[m] = RandomListNode(m.label)\n        m = m.next\n    while n:\n        dic[n].next = dic.get(n.next)\n        dic[n].random = dic.get(n.random)\n        n = n.next\n    return dic.get(head)\n</code><p>O(n)</p><pre><code>class Solution:\n# @param head, a RandomListNode\n# @return a RandomListNode\ndef copyRandomList(self, head):\n    dic = collections.defaultdict(lambda: RandomListNode(0))\n    dic[None] = None\n    n = head\n    while n:\n        dic[n].label = n.label\n        dic[n].next = dic[n.next]\n        dic[n].random = dic[n.random]\n        n = n.next\n    return dic[head]\n</code></pre><code>class Solution:\n# @param head, a RandomListNode\n# @return a RandomListNode\ndef copyRandomList(self, head):\n    dic = collections.defaultdict(lambda: RandomListNode(0))\n    dic[None] = None\n    n = head\n    while n:\n        dic[n].label = n.label\n        dic[n].next = dic[n.next]\n        dic[n].random = dic[n.random]\n        n = n.next\n    return dic[head]\n</code>", "votes": {"down": "0", "up": "4"}, "meta": {"author": "tusizi", "catagory": "Copy List with Random Pointer", "author_score": "20,650", "time": "2015-03-02T21:26:31+0000"}, "comments": [{"content": "<p>Could you please add more explanation and examples? Thanks so much! </p>", "votes": null, "meta": {"author": "zzhu06", "author_score": "900", "time": "2015-03-16T20:40:41+0000"}}, {"content": "<p>That second solution... brilliant. I'd just change <code>dic</code> to <code>copy</code> (and maybe <code>n</code> to <code>node</code> (and of course I'd indent the whole thing properly :-P)).</p><code>dic</code><code>copy</code><code>n</code><code>node</code>", "votes": null, "meta": {"author": "StefanPochmann", "author_score": "75,020", "time": "2015-06-28T20:55:03+0000"}}]}, "answers": [{"content": "<blockquote>\n  <p>What about this case: (the <code>\u2514</code> means the random pointer)</p>\n\n<pre><code>A-&gt;B-&gt;C-&gt;D\n\u2514-&gt;E-&gt;F\n   \u2514-&gt;G\n</code></pre>\n  \n  <p>Your solution didn't deal the List of random pointer.   Maybe it is\n  uncorrect.   I think your code will run out as:</p>\n\n<pre><code>A-&gt;B-&gt;C-&gt;D\n\u2514-&gt;E\n</code></pre>\n</blockquote><p>What about this case: (the <code>\u2514</code> means the random pointer)</p><code>\u2514</code><pre><code>A-&gt;B-&gt;C-&gt;D\n\u2514-&gt;E-&gt;F\n   \u2514-&gt;G\n</code></pre><code>A-&gt;B-&gt;C-&gt;D\n\u2514-&gt;E-&gt;F\n   \u2514-&gt;G\n</code><p>Your solution didn't deal the List of random pointer.   Maybe it is\n  uncorrect.   I think your code will run out as:</p><pre><code>A-&gt;B-&gt;C-&gt;D\n\u2514-&gt;E\n</code></pre><code>A-&gt;B-&gt;C-&gt;D\n\u2514-&gt;E\n</code><p>Sorry, I didn't see the sentence \"which could point to any node in the list or null\".<br>\nIt's my fault...</p><br>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "illuz", "author_score": "2,340", "time": "2015-03-28T02:50:03+0000"}}], "title": "Clear and short python O(2n) and O(n) solution"}, {"question": {"content": "<pre><code>class Solution:\n# @param s, a string\n# @param dict, a set of string\n# @return a list of strings\ndef wordBreak(self, s, dic):\n    if not dic:\n        return []\n    n = max(len(d) for d in dic)\n    stack, parents = [0], collections.defaultdict(set)\n    while stack:\n        parent = stack.pop()\n        for child in range(parent+1, parent+n+1):\n            if s[parent:child] in dic:\n                if child not in parents:\n                    stack.append(child)\n                parents[child].add(parent)\n    stack, res = [[len(s)]], []\n    while stack:\n        r = stack.pop()\n        if r[0] == 0:\n            r = [s[i:j] for i, j in zip(r[:-1], r[1:])]\n            res.append(' '.join(r))\n        for parent in parents[r[0]]:\n            stack.append([parent]+r)\n    return res\n</code></pre><code>class Solution:\n# @param s, a string\n# @param dict, a set of string\n# @return a list of strings\ndef wordBreak(self, s, dic):\n    if not dic:\n        return []\n    n = max(len(d) for d in dic)\n    stack, parents = [0], collections.defaultdict(set)\n    while stack:\n        parent = stack.pop()\n        for child in range(parent+1, parent+n+1):\n            if s[parent:child] in dic:\n                if child not in parents:\n                    stack.append(child)\n                parents[child].add(parent)\n    stack, res = [[len(s)]], []\n    while stack:\n        r = stack.pop()\n        if r[0] == 0:\n            r = [s[i:j] for i, j in zip(r[:-1], r[1:])]\n            res.append(' '.join(r))\n        for parent in parents[r[0]]:\n            stack.append([parent]+r)\n    return res\n</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "tusizi", "catagory": "Word Break II", "author_score": "20,650", "time": "2015-03-01T21:02:05+0000"}}, "answers": [], "title": "Python backtracking"}, {"question": {"content": "<pre><code>class Solution:\n# @return a list of lists of string\ndef solveNQueens(self, n):\n    stack, res = [[(0, i)] for i in range(n)], []\n    while stack:\n        board = stack.pop()\n        row = len(board)\n        if row == n:\n            res.append([''.join('Q' if i == c else '.' for i in range(n))\n                        for r, c in board])\n        for col in range(n):\n            if all(col != c and abs(row-r) != abs(col-c)for r, c in board):\n                stack.append(board+[(row, col)])\n    return res\n</code></pre><code>class Solution:\n# @return a list of lists of string\ndef solveNQueens(self, n):\n    stack, res = [[(0, i)] for i in range(n)], []\n    while stack:\n        board = stack.pop()\n        row = len(board)\n        if row == n:\n            res.append([''.join('Q' if i == c else '.' for i in range(n))\n                        for r, c in board])\n        for col in range(n):\n            if all(col != c and abs(row-r) != abs(col-c)for r, c in board):\n                stack.append(board+[(row, col)])\n    return res\n</code>", "votes": {"down": "1", "up": "7"}, "meta": {"author": "tusizi", "catagory": "N-Queens", "author_score": "20,650", "time": "2015-02-28T12:31:34+0000"}}, "answers": [{"content": "<p>Number of lines is a tradeoff, and sacrifice is readability.</p>", "votes": {"down": "1", "up": "8"}, "meta": {"author": "orekhov.volodya", "author_score": "1,520", "time": "2015-04-12T14:52:15+0000"}}], "title": "14 lines python code, DFS solution"}, {"question": {"content": "<pre><code>class Solution:\n# @param words, a list of strings\n# @param L, an integer\n# @return a list of strings\ndef fullJustify(self, words, length):\n    text = ' '.join(words)+' '\n    if text == ' ':\n        return [' '*length]\n    res = []\n    while text:\n        idx = text.rfind(' ', 0, length+1)\n        line = text[:idx].split()\n        l, n = sum(len(w) for w in line), len(line)\n        if n == 1:\n            res.append(line[0].ljust(length))\n        else:\n            s, remainder = divmod(length-l, n-1)\n            line[:-1] = [w+' '*s for w in line[:-1]]\n            line[:remainder] = [w+' ' for w in line[:remainder]]\n            res.append(''.join(line))\n        text = text[idx+1:]\n    res[-1] = ' '.join(res[-1].split()).ljust(length)\n    return res\n</code></pre><code>class Solution:\n# @param words, a list of strings\n# @param L, an integer\n# @return a list of strings\ndef fullJustify(self, words, length):\n    text = ' '.join(words)+' '\n    if text == ' ':\n        return [' '*length]\n    res = []\n    while text:\n        idx = text.rfind(' ', 0, length+1)\n        line = text[:idx].split()\n        l, n = sum(len(w) for w in line), len(line)\n        if n == 1:\n            res.append(line[0].ljust(length))\n        else:\n            s, remainder = divmod(length-l, n-1)\n            line[:-1] = [w+' '*s for w in line[:-1]]\n            line[:remainder] = [w+' ' for w in line[:remainder]]\n            res.append(''.join(line))\n        text = text[idx+1:]\n    res[-1] = ' '.join(res[-1].split()).ljust(length)\n    return res\n</code><p>The only trick to use the text and rfind to find every line.</p>", "votes": {"down": "0", "up": "2"}, "meta": {"author": "tusizi", "catagory": "Text Justification", "author_score": "20,650", "time": "2015-02-27T17:23:10+0000"}}, "answers": [], "title": "23 lines and clear python solution, can it be shorter?"}, {"question": {"content": "<pre><code>class Solution:\n# @param num, a list of integer\n# @return a list of lists of integers\ndef permuteUnique(self, num):\n    res = {()}\n    for n in num:\n        res = {r[:i]+(n,)+r[i:] for r in res for i in range(len(r)+1)}\n    return [list(r) for r in res]\n</code></pre><code>class Solution:\n# @param num, a list of integer\n# @return a list of lists of integers\ndef permuteUnique(self, num):\n    res = {()}\n    for n in num:\n        res = {r[:i]+(n,)+r[i:] for r in res for i in range(len(r)+1)}\n    return [list(r) for r in res]\n</code><p>recursion</p><pre><code>class Solution:\n# @param num, a list of integer\n# @return a list of lists of integers\ndef permuteUnique(self, num):\n    if not num:\n        return [[]]\n    num.sort()\n    res, prev = [], None\n    for n, i in enumerate(num):\n        if i != prev:\n            prev = i\n            for seq in self.permuteUnique(num[:n]+num[n+1:]):\n                res.append(seq+[i])\n    return res\n</code></pre><code>class Solution:\n# @param num, a list of integer\n# @return a list of lists of integers\ndef permuteUnique(self, num):\n    if not num:\n        return [[]]\n    num.sort()\n    res, prev = [], None\n    for n, i in enumerate(num):\n        if i != prev:\n            prev = i\n            for seq in self.permuteUnique(num[:n]+num[n+1:]):\n                res.append(seq+[i])\n    return res\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Permutations II", "author_score": "20,650", "time": "2015-02-27T14:47:20+0000"}}, "answers": [], "title": "Python set display and recursive solution"}, {"question": {"content": "<pre><code>class Solution:\n# @return a boolean\ndef isMatch(self, s, p):\n    length = len(s)\n    if len(p) - p.count('*') &gt; length:\n        return False\n    dp = [True] + [False]*length\n    for i in p:\n        if i != '*':\n            for n in reversed(range(length)):\n                dp[n+1] = dp[n] and (i == s[n] or i == '?')\n        else:\n            for n in range(1, length+1):\n                dp[n] = dp[n-1] or dp[n]\n        dp[0] = dp[0] and i == '*'\n    return dp[-1]\n</code></pre><code>class Solution:\n# @return a boolean\ndef isMatch(self, s, p):\n    length = len(s)\n    if len(p) - p.count('*') &gt; length:\n        return False\n    dp = [True] + [False]*length\n    for i in p:\n        if i != '*':\n            for n in reversed(range(length)):\n                dp[n+1] = dp[n] and (i == s[n] or i == '?')\n        else:\n            for n in range(1, length+1):\n                dp[n] = dp[n-1] or dp[n]\n        dp[0] = dp[0] and i == '*'\n    return dp[-1]\n</code><p>dp[n] means the substring s[:n] if match the pattern i</p><p>dp[0] means the empty string '' or s[:0] which only match the pattern '*'</p><p>use the reversed builtin because for every dp[n+1] we use the previous 'dp'</p><p>add Java O(m*n) version code</p><pre><code>public boolean isMatch(String s, String p) {\n    int count = 0;\n    for (char c : p.toCharArray()) {\n        if (c == '*')\n            count++;\n    }\n    if (p.length() - count &gt; s.length())\n        return false;\n    boolean[][] dp = new boolean[p.length() + 1][s.length() + 1];\n    dp[0][0] = true;\n    for (int j = 1; j &lt;= p.length(); j++) {\n        char pattern = p.charAt(j - 1);\n        dp[j][0] = dp[j - 1][0] &amp;&amp; pattern == '*';\n        for (int i = 1; i &lt;= s.length(); i++) {\n            char letter = s.charAt(i - 1);\n            if (pattern != '*') {\n                dp[j][i] = dp[j - 1][i - 1] &amp;&amp; (pattern == '?' || pattern == letter);\n            } else\n                dp[j][i] = dp[j][i - 1] || dp[j - 1][i];\n        }\n    }\n    return dp[p.length()][s.length()];\n}\n</code></pre><code>public boolean isMatch(String s, String p) {\n    int count = 0;\n    for (char c : p.toCharArray()) {\n        if (c == '*')\n            count++;\n    }\n    if (p.length() - count &gt; s.length())\n        return false;\n    boolean[][] dp = new boolean[p.length() + 1][s.length() + 1];\n    dp[0][0] = true;\n    for (int j = 1; j &lt;= p.length(); j++) {\n        char pattern = p.charAt(j - 1);\n        dp[j][0] = dp[j - 1][0] &amp;&amp; pattern == '*';\n        for (int i = 1; i &lt;= s.length(); i++) {\n            char letter = s.charAt(i - 1);\n            if (pattern != '*') {\n                dp[j][i] = dp[j - 1][i - 1] &amp;&amp; (pattern == '?' || pattern == letter);\n            } else\n                dp[j][i] = dp[j][i - 1] || dp[j - 1][i];\n        }\n    }\n    return dp[p.length()][s.length()];\n}\n</code>", "votes": {"down": "0", "up": "9"}, "meta": {"author": "tusizi", "catagory": "Wildcard Matching", "author_score": "20,650", "time": "2015-02-26T20:09:50+0000"}, "comments": [{"content": "<p>Awesome answer!</p>", "votes": null, "meta": {"author": "weihsin.chen.906", "author_score": "310", "time": "2015-05-16T13:00:49+0000"}}]}, "answers": [], "title": "Python DP solution"}, {"question": {"content": "<p>The water we trapped depends on the left side and right side which has the max height,</p><p>We keep the left side and right side until we find a higher side</p><pre><code>class Solution:\n# @param A, a list of integers\n# @return an integer\ndef trap(self, arr):\n    height, left, right, water = [], 0, 0, 0\n    for i in arr:\n        left = max(left, i)\n        height.append(left)\n    height.reverse()\n    for n, i in enumerate(reversed(arr)):\n        right = max(right, i)\n        water += min(height[n], right) - i\n    return water\n</code></pre><code>class Solution:\n# @param A, a list of integers\n# @return an integer\ndef trap(self, arr):\n    height, left, right, water = [], 0, 0, 0\n    for i in arr:\n        left = max(left, i)\n        height.append(left)\n    height.reverse()\n    for n, i in enumerate(reversed(arr)):\n        right = max(right, i)\n        water += min(height[n], right) - i\n    return water\n</code><p>O(1)</p><pre><code>class Solution:\n# @param A, a list of integers\n# @return an integer\ndef trap(self, arr):\n    left = right = water = 0\n    i, j = 0, len(arr)-1\n    while i &lt;= j:\n        left, right = max(left, arr[i]), max(right, arr[j])\n        while i &lt;= j and arr[i] &lt;= left &lt;= right:\n            water += left - arr[i]\n            i += 1\n        while i &lt;= j and arr[j] &lt;= right &lt;= left:\n            water += right - arr[j]\n            j -= 1\n    return water\n</code></pre><code>class Solution:\n# @param A, a list of integers\n# @return an integer\ndef trap(self, arr):\n    left = right = water = 0\n    i, j = 0, len(arr)-1\n    while i &lt;= j:\n        left, right = max(left, arr[i]), max(right, arr[j])\n        while i &lt;= j and arr[i] &lt;= left &lt;= right:\n            water += left - arr[i]\n            i += 1\n        while i &lt;= j and arr[j] &lt;= right &lt;= left:\n            water += right - arr[j]\n            j -= 1\n    return water\n</code>", "votes": {"down": "0", "up": "4"}, "meta": {"author": "tusizi", "catagory": "Trapping Rain Water", "author_score": "20,650", "time": "2015-02-26T13:17:05+0000"}}, "answers": [], "title": "Python solutions, O(n) space and O(1) space"}, {"question": {"content": "<pre><code>class Solution:\n# @return a boolean\ndef isMatch(self, s, p):\n    def append(string, index):\n        if (string, index) not in visited:\n            visited.add((string, index))\n            stack.append((string, index))\n\n    graph, stack, visited = [], [(s, 0)], {(s, 0)}\n    for i in p:\n        if i == '*':\n            graph[-1] += '*'\n        else:\n            graph.append(i)\n    while stack:\n        s, idx = stack.pop()\n        if idx == len(graph):\n            if not s:\n                return True\n            else:\n                continue\n        pattern = graph[idx]\n        if pattern == '.*':\n            for i in range(len(s)+1):\n                append(s[i:], idx+1)\n        elif pattern.endswith('*'):\n            head = pattern[0]\n            for i in range(len(s)+1):\n                if s.startswith(head*i):\n                    append(s[i:], idx+1)\n                else:\n                    break\n        elif pattern == '.' and s:\n            append(s[1:], idx+1)\n        elif s.startswith(pattern):\n            append(s[1:], idx+1)\n    return False\n</code></pre><code>class Solution:\n# @return a boolean\ndef isMatch(self, s, p):\n    def append(string, index):\n        if (string, index) not in visited:\n            visited.add((string, index))\n            stack.append((string, index))\n\n    graph, stack, visited = [], [(s, 0)], {(s, 0)}\n    for i in p:\n        if i == '*':\n            graph[-1] += '*'\n        else:\n            graph.append(i)\n    while stack:\n        s, idx = stack.pop()\n        if idx == len(graph):\n            if not s:\n                return True\n            else:\n                continue\n        pattern = graph[idx]\n        if pattern == '.*':\n            for i in range(len(s)+1):\n                append(s[i:], idx+1)\n        elif pattern.endswith('*'):\n            head = pattern[0]\n            for i in range(len(s)+1):\n                if s.startswith(head*i):\n                    append(s[i:], idx+1)\n                else:\n                    break\n        elif pattern == '.' and s:\n            append(s[1:], idx+1)\n        elif s.startswith(pattern):\n            append(s[1:], idx+1)\n    return False\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Regular Expression Matching", "author_score": "20,650", "time": "2015-02-25T18:40:58+0000"}}, "answers": [], "title": "Think less, write more, lol, 70ms python DFS solution"}, {"question": {"content": "<pre><code>class Solution:\n# @param nums, a list of integer\n# @param k, num of steps\n# @return nothing, please modify the nums list in-place.\ndef rotate(self, nums, k):\n    k %= len(nums)\n    nums[:] = nums[-k:]+nums[:-k]\n</code></pre><code>class Solution:\n# @param nums, a list of integer\n# @param k, num of steps\n# @return nothing, please modify the nums list in-place.\ndef rotate(self, nums, k):\n    k %= len(nums)\n    nums[:] = nums[-k:]+nums[:-k]\n</code>", "votes": {"down": "0", "up": "2"}, "meta": {"author": "tusizi", "catagory": "Rotate Array", "author_score": "20,650", "time": "2015-02-25T15:34:11+0000"}, "comments": [{"content": "<p>Could you please add more explanation and examples? Thanks! </p>", "votes": null, "meta": {"author": "zzhu06", "author_score": "900", "time": "2015-03-02T20:54:35+0000"}}, {"content": "<p>s[i:j] = t means slice of s from i to j is replaced by the contents of the iterable t</p><p>please see https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types</p>", "votes": null, "meta": {"author": "tusizi", "author_score": "20,650", "time": "2015-03-04T14:45:41+0000"}}]}, "answers": [], "title": "Straight forward python code, use slice"}, {"question": {"content": "<pre><code>class Solution:\n# @param s, a string\n# @return a list of strings\ndef findRepeatedDnaSequences(self, s):\n    c = collections.Counter(s[i:i+10] for i in range(len(s)))\n    return [k for k in c if c.get(k) &gt; 1]\n</code></pre><code>class Solution:\n# @param s, a string\n# @return a list of strings\ndef findRepeatedDnaSequences(self, s):\n    c = collections.Counter(s[i:i+10] for i in range(len(s)))\n    return [k for k in c if c.get(k) &gt; 1]\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Repeated DNA Sequences", "author_score": "20,650", "time": "2015-02-22T13:34:48+0000"}}, "answers": [], "title": "Clear and short python code use Counter"}, {"question": {"content": "<pre><code>class Solution:\n# @param root, a tree node\n# @return a boolean\ndef isValidBST(self, root):\n    pre, cur, stack = None, root, []\n    while stack or cur:\n        while cur:\n            stack.append(cur)\n            cur = cur.left\n        s = stack.pop()\n        if pre and s.val &lt;= pre.val:\n            return False\n        pre, cur = s, s.right\n    return True\n</code></pre><code>class Solution:\n# @param root, a tree node\n# @return a boolean\ndef isValidBST(self, root):\n    pre, cur, stack = None, root, []\n    while stack or cur:\n        while cur:\n            stack.append(cur)\n            cur = cur.left\n        s = stack.pop()\n        if pre and s.val &lt;= pre.val:\n            return False\n        pre, cur = s, s.right\n    return True\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Validate Binary Search Tree", "author_score": "20,650", "time": "2015-02-21T13:05:42+0000"}}, "answers": [], "title": "Python Inorder Traversal"}, {"question": {"content": "<pre><code>class Solution:\n# @return a list of lists of length 4, [[val1,val2,val3,val4]]\ndef fourSum(self, num, target):\n    two_sum = collections.defaultdict(list)\n    res = set()\n    for (n1, i1), (n2, i2) in itertools.combinations(enumerate(num), 2):\n        two_sum[i1+i2].append({n1, n2})\n    for t in list(two_sum.keys()):\n        if not two_sum[target-t]:\n            continue\n        for pair1 in two_sum[t]:\n            for pair2 in two_sum[target-t]:\n                if pair1.isdisjoint(pair2):\n                    res.add(tuple(sorted(num[i] for i in pair1 | pair2)))\n        del two_sum[t]\n    return [list(r) for r in res]\n</code></pre><code>class Solution:\n# @return a list of lists of length 4, [[val1,val2,val3,val4]]\ndef fourSum(self, num, target):\n    two_sum = collections.defaultdict(list)\n    res = set()\n    for (n1, i1), (n2, i2) in itertools.combinations(enumerate(num), 2):\n        two_sum[i1+i2].append({n1, n2})\n    for t in list(two_sum.keys()):\n        if not two_sum[target-t]:\n            continue\n        for pair1 in two_sum[t]:\n            for pair2 in two_sum[target-t]:\n                if pair1.isdisjoint(pair2):\n                    res.add(tuple(sorted(num[i] for i in pair1 | pair2)))\n        del two_sum[t]\n    return [list(r) for r in res]\n</code>", "votes": {"down": "0", "up": "3"}, "meta": {"author": "tusizi", "catagory": "4Sum", "author_score": "20,650", "time": "2015-02-20T12:44:35+0000"}}, "answers": [], "title": "twoSum+twoSum == fourSum, a simple python solution"}, {"question": {"content": "<pre><code>class Solution:\n# @param root, a tree node\n# @return a list of lists of integers\ndef zigzagLevelOrder(self, root):\n    queue = collections.deque([root])\n    res = []\n    while queue:\n        r = []\n        for _ in range(len(queue)):\n            q = queue.popleft()\n            if q:\n                r.append(q.val)\n                queue.append(q.left)\n                queue.append(q.right)\n        r = r[::-1] if len(res) % 2 else r\n        if r:\n            res.append(r)\n    return res\n</code></pre><code>class Solution:\n# @param root, a tree node\n# @return a list of lists of integers\ndef zigzagLevelOrder(self, root):\n    queue = collections.deque([root])\n    res = []\n    while queue:\n        r = []\n        for _ in range(len(queue)):\n            q = queue.popleft()\n            if q:\n                r.append(q.val)\n                queue.append(q.left)\n                queue.append(q.right)\n        r = r[::-1] if len(res) % 2 else r\n        if r:\n            res.append(r)\n    return res\n</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "tusizi", "catagory": "Binary Tree Zigzag Level Order Traversal", "author_score": "20,650", "time": "2015-02-18T17:57:24+0000"}}, "answers": [{"content": "<p>Mine is very similar</p><pre><code>from collections import deque\nclass Solution:\n    # @param root, a tree node\n    # @return a list of lists of integers\n    def zigzagLevelOrder(self, root):\n        queue = deque()\n        queue.append(root)\n        switch = True #left to right\n        ans = []\n        if (root):\n            while(queue):\n                level = []\n                for i in range(len(queue)):\n                    node = queue.popleft()\n                    level.append(node.val)\n                    self.appendNode(queue, node.left)\n                    self.appendNode(queue, node.right)\n\n                if (not switch):\n                    level.reverse()\n\n                ans.append(level)\n                switch = not switch\n        return ans\n\n    def appendNode(self, queue, node):\n        if (node):\n            queue.append(node)\n</code></pre><code>from collections import deque\nclass Solution:\n    # @param root, a tree node\n    # @return a list of lists of integers\n    def zigzagLevelOrder(self, root):\n        queue = deque()\n        queue.append(root)\n        switch = True #left to right\n        ans = []\n        if (root):\n            while(queue):\n                level = []\n                for i in range(len(queue)):\n                    node = queue.popleft()\n                    level.append(node.val)\n                    self.appendNode(queue, node.left)\n                    self.appendNode(queue, node.right)\n\n                if (not switch):\n                    level.reverse()\n\n                ans.append(level)\n                switch = not switch\n        return ans\n\n    def appendNode(self, queue, node):\n        if (node):\n            queue.append(node)\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "thinhlamtruongnguyen", "author_score": "130", "time": "2015-02-23T05:14:49+0000"}}, {"content": "<p>I like this deque solution. although it may not be what they want. And there some extra cost of reversing. However, it is indeed much clear and concise.</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "hu.cao1", "author_score": "2,370", "time": "2015-03-20T14:28:23+0000"}}], "title": "Short and clear python code"}, {"question": {"content": "<pre><code>class Solution:\n# @param head, a ListNode\n# @return a ListNode\ndef deleteDuplicates(self, head):\n    root = node = prev_node = prev_val = ListNode(0)\n    while head:\n        while head and head.val == prev_val:\n            head = head.next\n            node = prev_node\n        node.next = head\n        prev_node, node = node, node.next\n        if head:\n            prev_val = head.val\n            head = head.next\n    return root.next\n</code></pre><code>class Solution:\n# @param head, a ListNode\n# @return a ListNode\ndef deleteDuplicates(self, head):\n    root = node = prev_node = prev_val = ListNode(0)\n    while head:\n        while head and head.val == prev_val:\n            head = head.next\n            node = prev_node\n        node.next = head\n        prev_node, node = node, node.next\n        if head:\n            prev_val = head.val\n            head = head.next\n    return root.next\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Remove Duplicates from Sorted List II", "author_score": "20,650", "time": "2015-02-15T15:00:56+0000"}}, "answers": [], "title": "Clear and short python solution"}, {"question": {"content": "<pre><code>class Solution:\n# @param s, a string\n# @return a list of lists of string\ndef partition(self, s):\n    graph = collections.defaultdict(set)\n    n = len(s)\n    for j in range(n):\n        for i in range(j, n):\n            if s[j:i+1] == s[j:i+1][::-1]:\n                graph[j].add(i+1)\n    stack, res = [[0]], []\n    while stack:\n        route = stack.pop()\n        node = route[-1]\n        if node == n:\n            res.append([s[j:i] for (j, i) in zip(route[:-1], route[1:])])\n        for neighbor in graph[node]:\n            stack.append(route+[neighbor])\n    return res\n</code></pre><code>class Solution:\n# @param s, a string\n# @return a list of lists of string\ndef partition(self, s):\n    graph = collections.defaultdict(set)\n    n = len(s)\n    for j in range(n):\n        for i in range(j, n):\n            if s[j:i+1] == s[j:i+1][::-1]:\n                graph[j].add(i+1)\n    stack, res = [[0]], []\n    while stack:\n        route = stack.pop()\n        node = route[-1]\n        if node == n:\n            res.append([s[j:i] for (j, i) in zip(route[:-1], route[1:])])\n        for neighbor in graph[node]:\n            stack.append(route+[neighbor])\n    return res\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Palindrome Partitioning", "author_score": "20,650", "time": "2015-02-12T16:35:19+0000"}}, "answers": [], "title": "Build a graph and DFS, a 120ms AC and dry python code"}, {"question": {"content": "<pre><code>class Solution:\n# @return an integer\ndef divide(self, dividend, divisor):\n    positive = (dividend &lt; 0) is (divisor &lt; 0)\n    dividend, divisor = abs(dividend), abs(divisor)\n    res = 0\n    while dividend &gt;= divisor:\n        temp, i = divisor, 1\n        while dividend &gt;= temp:\n            dividend -= temp\n            res += i\n            i &lt;&lt;= 1\n            temp &lt;&lt;= 1\n    if not positive:\n        res = -res\n    return min(max(-2147483648, res), 2147483647)\n</code></pre><code>class Solution:\n# @return an integer\ndef divide(self, dividend, divisor):\n    positive = (dividend &lt; 0) is (divisor &lt; 0)\n    dividend, divisor = abs(dividend), abs(divisor)\n    res = 0\n    while dividend &gt;= divisor:\n        temp, i = divisor, 1\n        while dividend &gt;= temp:\n            dividend -= temp\n            res += i\n            i &lt;&lt;= 1\n            temp &lt;&lt;= 1\n    if not positive:\n        res = -res\n    return min(max(-2147483648, res), 2147483647)\n</code>", "votes": {"down": "0", "up": "18"}, "meta": {"author": "tusizi", "catagory": "Divide Two Integers", "author_score": "20,650", "time": "2015-02-11T07:32:54+0000"}, "comments": [{"content": "<p>Wow this code is elegant! Thanks for sharing!</p>", "votes": null, "meta": {"author": "chungyushao", "author_score": "4,430", "time": "2015-07-14T13:24:39+0000"}}]}, "answers": [], "title": "Clear python code"}, {"question": {"content": "<pre><code>class Solution:\n# @param an integer\n# @return a list of string\ndef generateParenthesis(self, n):\n    res = {'()'}\n    for i in range(n-1):\n        res = {r[:m+1]+'()'+r[m+1:] for r in res for m in range(i, 2*i+2)}\n    return list(res)\n</code></pre><code>class Solution:\n# @param an integer\n# @return a list of string\ndef generateParenthesis(self, n):\n    res = {'()'}\n    for i in range(n-1):\n        res = {r[:m+1]+'()'+r[m+1:] for r in res for m in range(i, 2*i+2)}\n    return list(res)\n</code><p>It seems set is enough</p>", "votes": {"down": "1", "up": "1"}, "meta": {"author": "tusizi", "catagory": "Generate Parentheses", "author_score": "20,650", "time": "2015-02-05T13:13:55+0000"}}, "answers": [], "title": "Straight forward, Brute Force?"}, {"question": {"content": "<pre><code>class Solution:\n# @return a string\ndef convert(self, s, n):\n    res = [[] for _ in range(n)]\n    i = 0\n    try:\n        while True:\n            for r in res:\n                r.append(s[i])\n                i += 1\n            for r in res[-2:0:-1]:\n                r.append(s[i])\n                i += 1\n    except IndexError:\n        return ''.join(''.join(r) for r in res)\n</code></pre><code>class Solution:\n# @return a string\ndef convert(self, s, n):\n    res = [[] for _ in range(n)]\n    i = 0\n    try:\n        while True:\n            for r in res:\n                r.append(s[i])\n                i += 1\n            for r in res[-2:0:-1]:\n                r.append(s[i])\n                i += 1\n    except IndexError:\n        return ''.join(''.join(r) for r in res)\n</code><p>Here's a neat one</p><pre><code>class Solution:\n# @return a string\ndef convert(self, s, n):\n    idx = itertools.chain(range(n), range(n-2, 0, -1))\n    res = [[] for _ in range(n)]\n    for char, i in zip(s, itertools.cycle(idx)):\n        res[i].append(char)\n    return ''.join(''.join(r) for r in res)\n</code></pre><code>class Solution:\n# @return a string\ndef convert(self, s, n):\n    idx = itertools.chain(range(n), range(n-2, 0, -1))\n    res = [[] for _ in range(n)]\n    for char, i in zip(s, itertools.cycle(idx)):\n        res[i].append(char)\n    return ''.join(''.join(r) for r in res)\n</code>", "votes": {"down": "0", "up": "4"}, "meta": {"author": "tusizi", "catagory": "ZigZag Conversion", "author_score": "20,650", "time": "2015-02-04T09:35:34+0000"}, "comments": [{"content": "<p>The slice one is pretty damn smart. Haven't really thought I could use slice that way. Using the iterloop ones makes me feel naughty. lol</p>", "votes": null, "meta": {"author": "ningchris", "author_score": "180", "time": "2015-02-08T22:33:56+0000"}}]}, "answers": [], "title": "Two python code, straight forward use slice and neat use itertools"}, {"question": {"content": "<pre><code>class Solution:\n# @param start, a string\n# @param end, a string\n# @param dict, a set of string\n# @return a list of lists of string\ndef findLadders(self, start, end, dic):\n    dic.add(end)\n    level = {start}\n    parents = collections.defaultdict(set)\n    while level and end not in parents:\n        next_level = collections.defaultdict(set)\n        for node in level:\n            for char in string.ascii_lowercase:\n                for i in range(len(start)):\n                    n = node[:i]+char+node[i+1:]\n                    if n in dic and n not in parents:\n                        next_level[n].add(node)\n        level = next_level\n        parents.update(next_level)\n    res = [[end]]\n    while res and res[0][0] != start:\n        res = [[p]+r for r in res for p in parents[r[0]]]\n    return res\n</code></pre><code>class Solution:\n# @param start, a string\n# @param end, a string\n# @param dict, a set of string\n# @return a list of lists of string\ndef findLadders(self, start, end, dic):\n    dic.add(end)\n    level = {start}\n    parents = collections.defaultdict(set)\n    while level and end not in parents:\n        next_level = collections.defaultdict(set)\n        for node in level:\n            for char in string.ascii_lowercase:\n                for i in range(len(start)):\n                    n = node[:i]+char+node[i+1:]\n                    if n in dic and n not in parents:\n                        next_level[n].add(node)\n        level = next_level\n        parents.update(next_level)\n    res = [[end]]\n    while res and res[0][0] != start:\n        res = [[p]+r for r in res for p in parents[r[0]]]\n    return res\n</code><p>Every level we use the defaultdict to get rid of the duplicates</p>", "votes": {"down": "0", "up": "8"}, "meta": {"author": "tusizi", "catagory": "Word Ladder II", "author_score": "20,650", "time": "2015-02-03T15:28:29+0000"}}, "answers": [], "title": "use defaultdict for traceback and easy writing, 20 lines python code"}, {"question": {"content": "<pre><code>class Solution:\n# @param board, a 9x9 2D array\n# Solve the Sudoku by modifying the input board in-place.\n# Do not return any value.\ndef solveSudoku(self, board):\n    res = self.dfs(board)\n    for n, row in enumerate(res):\n        board[n] = ''.join(row)\n\ndef dfs(self, board):\n    stack = [board]\n    while stack:\n        s = stack.pop()\n        result = self.fill_board(s)\n        if result == 'complete':\n            return s\n        for r in result:\n            stack.append(r)\n\ndef fill_board(self, board):\n    digits = set('123456789')\n    choice, best = {}, []\n    for j in range(9):\n        for i in range(9):\n            if board[j][i] == '.':\n                square = {board[j//3*3+y][i//3*3+x]\n                          for y in range(3) for x in range(3)}\n                row = {board[j][x] for x in range(9)}\n                col = {board[y][i] for y in range(9)}\n                rest = digits.difference(square, row, col)\n                if len(rest) == 1:\n                    board[j][i] = rest.pop()\n                    return self.fill_board(board)\n                elif len(rest) == 0:\n                    return ''\n                else:\n                    choice[(j, i)] = rest\n    if not choice:\n        return 'complete'\n    y, x = min(choice, key=lambda k: len(choice[k]))\n    for n in choice[(y, x)]:\n        b = copy.deepcopy(board)\n        b[y][x] = n\n        best.append(b)\n    return best\n</code></pre><code>class Solution:\n# @param board, a 9x9 2D array\n# Solve the Sudoku by modifying the input board in-place.\n# Do not return any value.\ndef solveSudoku(self, board):\n    res = self.dfs(board)\n    for n, row in enumerate(res):\n        board[n] = ''.join(row)\n\ndef dfs(self, board):\n    stack = [board]\n    while stack:\n        s = stack.pop()\n        result = self.fill_board(s)\n        if result == 'complete':\n            return s\n        for r in result:\n            stack.append(r)\n\ndef fill_board(self, board):\n    digits = set('123456789')\n    choice, best = {}, []\n    for j in range(9):\n        for i in range(9):\n            if board[j][i] == '.':\n                square = {board[j//3*3+y][i//3*3+x]\n                          for y in range(3) for x in range(3)}\n                row = {board[j][x] for x in range(9)}\n                col = {board[y][i] for y in range(9)}\n                rest = digits.difference(square, row, col)\n                if len(rest) == 1:\n                    board[j][i] = rest.pop()\n                    return self.fill_board(board)\n                elif len(rest) == 0:\n                    return ''\n                else:\n                    choice[(j, i)] = rest\n    if not choice:\n        return 'complete'\n    y, x = min(choice, key=lambda k: len(choice[k]))\n    for n in choice[(y, x)]:\n        b = copy.deepcopy(board)\n        b[y][x] = n\n        best.append(b)\n    return best\n</code><p>Every time we find a '.', we store the possible numbers we can choice in a dict,</p><p>if the possible numbers is only one, we fill the board first and refill the board from beginning,</p><p>and last , we choose a position where the possible numbers is least to continue search</p>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "tusizi", "catagory": "Sudoku Solver", "author_score": "20,650", "time": "2015-02-01T13:23:01+0000"}}, "answers": [], "title": "80ms python code, use dfs with choice"}, {"question": {"content": "<pre><code>class Solution:\n# @param intervals, a list of Interval\n# @return a list of Interval\ndef merge(self, intervals):\n    intervals.sort(key=lambda x: x.start)\n    res = []\n    for i in intervals:\n        if res and i.start &lt;= res[-1].end:\n            res[-1].end = max(i.end, res[-1].end)\n        else:\n            res.append(i)\n    return res\n</code></pre><code>class Solution:\n# @param intervals, a list of Interval\n# @return a list of Interval\ndef merge(self, intervals):\n    intervals.sort(key=lambda x: x.start)\n    res = []\n    for i in intervals:\n        if res and i.start &lt;= res[-1].end:\n            res[-1].end = max(i.end, res[-1].end)\n        else:\n            res.append(i)\n    return res\n</code><p>Don't write this</p><pre><code>        if intervals == []:\n</code></pre><code>        if intervals == []:\n</code><p>Just </p><pre><code>        if not intervals:\n</code></pre><code>        if not intervals:\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Merge Intervals", "author_score": "20,650", "time": "2015-01-31T07:22:40+0000"}, "comments": [{"content": "<p>Could you please provide some examples and explain how to test them? Thanks a lot! </p>", "votes": null, "meta": {"author": "zzhu06", "author_score": "900", "time": "2015-03-19T22:42:31+0000"}}]}, "answers": [], "title": "Same idea, use fewer lines, python code"}, {"question": {"content": "<pre><code>class Solution:\n# @param num, a list of integer\n# @return an integer\ndef longestConsecutive(self, num):\n    numbers = set(num)\n    max_len = 0\n    while numbers:\n        m = n = numbers.pop()\n        length = 1\n        while m-1 in numbers:\n            numbers.remove(m-1)\n            m -= 1\n            length += 1\n        while n+1 in numbers:\n            numbers.remove(n+1)\n            n += 1\n            length += 1\n        max_len = max(max_len, length)\n    return max_len\n</code></pre><code>class Solution:\n# @param num, a list of integer\n# @return an integer\ndef longestConsecutive(self, num):\n    numbers = set(num)\n    max_len = 0\n    while numbers:\n        m = n = numbers.pop()\n        length = 1\n        while m-1 in numbers:\n            numbers.remove(m-1)\n            m -= 1\n            length += 1\n        while n+1 in numbers:\n            numbers.remove(n+1)\n            n += 1\n            length += 1\n        max_len = max(max_len, length)\n    return max_len\n</code><p>keep trace of the max_len</p>", "votes": {"down": "0", "up": "3"}, "meta": {"author": "tusizi", "catagory": "Longest Consecutive Sequence", "author_score": "20,650", "time": "2015-01-27T09:15:15+0000"}}, "answers": [{"content": "<p>it seems that your time is O(n^2) since each poped elements are checked in the list for its adj. elements.</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "pennlio", "author_score": "420", "time": "2015-02-05T03:51:38+0000"}, "comments": [{"content": "<p>Not exactly. set() is a hashtable</p>", "votes": null, "meta": {"author": "hyshen2", "author_score": "110", "time": "2015-02-08T19:35:31+0000"}}]}], "title": "Remove number from set consecutively, a dry python code"}, {"question": {"content": "<pre><code>class Solution:\n# @param s, a string\n# @return an integer\ndef numDecodings(self, s):\n    if not s or s.startswith('0'):\n        return 0\n    stack = [1, 1]\n    for i in range(1, len(s)):\n        if s[i] == '0':\n            if s[i-1] == '0' or s[i-1] &gt; '2':  # only '10', '20' is valid\n                return 0\n            stack.append(stack[-2])\n        elif 9 &lt; int(s[i-1:i+1]) &lt; 27:         # '01 - 09' is not allowed\n            stack.append(stack[-2]+stack[-1])\n        else:                                  # other case '01, 09, 27'\n            stack.append(stack[-1])\n    return stack[-1]\n</code></pre><code>class Solution:\n# @param s, a string\n# @return an integer\ndef numDecodings(self, s):\n    if not s or s.startswith('0'):\n        return 0\n    stack = [1, 1]\n    for i in range(1, len(s)):\n        if s[i] == '0':\n            if s[i-1] == '0' or s[i-1] &gt; '2':  # only '10', '20' is valid\n                return 0\n            stack.append(stack[-2])\n        elif 9 &lt; int(s[i-1:i+1]) &lt; 27:         # '01 - 09' is not allowed\n            stack.append(stack[-2]+stack[-1])\n        else:                                  # other case '01, 09, 27'\n            stack.append(stack[-1])\n    return stack[-1]\n</code><p>A digit from index 1 have three condition</p><ol>\n<li><p>'?10' or '?20'  this can only divide into '10'   or   '20' , f(n) = f(n-2)</p></li>\n<li><p>'?26'  this can divide into '6' or '26', f(n) = f(n-2)+f(n-1)</p></li>\n<li><p>'?09', '?27' this can only divide into '9'    or   '7' , f(n) = f(n-1)</p></li>\n</ol><li><p>'?10' or '?20'  this can only divide into '10'   or   '20' , f(n) = f(n-2)</p></li><p>'?10' or '?20'  this can only divide into '10'   or   '20' , f(n) = f(n-2)</p><li><p>'?26'  this can divide into '6' or '26', f(n) = f(n-2)+f(n-1)</p></li><p>'?26'  this can divide into '6' or '26', f(n) = f(n-2)+f(n-1)</p><li><p>'?09', '?27' this can only divide into '9'    or   '7' , f(n) = f(n-1)</p></li><p>'?09', '?27' this can only divide into '9'    or   '7' , f(n) = f(n-1)</p>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "tusizi", "catagory": "Decode Ways", "author_score": "20,650", "time": "2015-01-26T08:08:19+0000"}}, "answers": [], "title": "Python DP solution"}, {"question": {"content": "<pre><code>class Solution:\n# @param start, a string\n# @param end, a string\n# @param dict, a set of string\n# @return an integer\ndef ladderLength(self, start, end, words):\n    start_set, end_set = {start}, {end}\n    n = len(start)\n    chars = string.ascii_lowercase\n    queue1 = collections.deque([start])\n    queue2 = collections.deque([end])\n    len1, len2 = 1, 1\n    while queue1 and queue2:\n        i, j = len(queue1), len(queue2)\n        for _ in range(i):\n            q = queue1.popleft()\n            for idx in range(n):\n                for c in chars:\n                    w = q[:idx]+c+q[idx+1:]\n                    if w in end_set:\n                        return len1+len2\n                    if w in words and w not in start_set:\n                        start_set.add(w)\n                        queue1.append(w)\n        len1 += 1\n        for _ in range(j):\n            q = queue2.popleft()\n            for idx in range(n):\n                for c in chars:\n                    w = q[:idx]+c+q[idx+1:]\n                    if w in start_set:\n                        return len1+len2\n                    if w in words and w not in end_set:\n                        end_set.add(w)\n                        queue2.append(w)\n        len2 += 1\n    return 0\n</code></pre><code>class Solution:\n# @param start, a string\n# @param end, a string\n# @param dict, a set of string\n# @return an integer\ndef ladderLength(self, start, end, words):\n    start_set, end_set = {start}, {end}\n    n = len(start)\n    chars = string.ascii_lowercase\n    queue1 = collections.deque([start])\n    queue2 = collections.deque([end])\n    len1, len2 = 1, 1\n    while queue1 and queue2:\n        i, j = len(queue1), len(queue2)\n        for _ in range(i):\n            q = queue1.popleft()\n            for idx in range(n):\n                for c in chars:\n                    w = q[:idx]+c+q[idx+1:]\n                    if w in end_set:\n                        return len1+len2\n                    if w in words and w not in start_set:\n                        start_set.add(w)\n                        queue1.append(w)\n        len1 += 1\n        for _ in range(j):\n            q = queue2.popleft()\n            for idx in range(n):\n                for c in chars:\n                    w = q[:idx]+c+q[idx+1:]\n                    if w in start_set:\n                        return len1+len2\n                    if w in words and w not in end_set:\n                        end_set.add(w)\n                        queue2.append(w)\n        len2 += 1\n    return 0\n</code><p>My BFS solution got 600ms AC, can anyone give me a faster solution than this?</p>", "votes": {"down": "0", "up": "2"}, "meta": {"author": "tusizi", "catagory": "Word Ladder", "author_score": "20,650", "time": "2015-01-26T05:38:23+0000"}}, "answers": [], "title": "My python double_BFS got 322ms AC, Is there a A* solution can be faster than this?"}, {"question": {"content": "<pre><code>class Solution:\n# @param path, a string\n# @return a string\ndef simplifyPath(self, path):\n    stack = []\n    for i in path.split('/'):\n        if i == '..':\n            if stack:\n                stack.pop()\n        elif i == '.':\n            continue\n        elif i:\n            stack.append(i)\n    return '/' + '/'.join(stack)\n</code></pre><code>class Solution:\n# @param path, a string\n# @return a string\ndef simplifyPath(self, path):\n    stack = []\n    for i in path.split('/'):\n        if i == '..':\n            if stack:\n                stack.pop()\n        elif i == '.':\n            continue\n        elif i:\n            stack.append(i)\n    return '/' + '/'.join(stack)\n</code><p>bool('') == False and bool([])  == false</p><p>use this for easy writing</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Simplify Path", "author_score": "20,650", "time": "2015-01-25T12:00:57+0000"}}, "answers": [], "title": "some truth value testing in python"}, {"question": {"content": "<pre><code>class Solution:\n# @param tokens, a list of string\n# @return an integer\ndef evalRPN(self, tokens):\n    stack = []\n    ops = {'+': operator.add, '-': operator.sub,\n           '*': operator.mul, '/': operator.truediv}\n    for i in tokens:\n        if i in ops:\n            a, b = stack.pop(), stack.pop()\n            stack.append(ops[i](b, a))\n        else:\n            stack.append(int(i))\n    return stack[0]\n</code></pre><code>class Solution:\n# @param tokens, a list of string\n# @return an integer\ndef evalRPN(self, tokens):\n    stack = []\n    ops = {'+': operator.add, '-': operator.sub,\n           '*': operator.mul, '/': operator.truediv}\n    for i in tokens:\n        if i in ops:\n            a, b = stack.pop(), stack.pop()\n            stack.append(ops[i](b, a))\n        else:\n            stack.append(int(i))\n    return stack[0]\n</code><p>int(truediv(a,b)) get the same result as Java or CPP</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Evaluate Reverse Polish Notation", "author_score": "20,650", "time": "2015-01-25T10:42:29+0000"}}, "answers": [], "title": "use truediv instead of floordiv in python to get the right answer"}, {"question": {"content": "<pre><code>class Solution:\n# @return an integer\ndef lengthOfLongestSubstring(self, s):\n    char_dict = dict()\n    start, length = 0, 0\n    for n, char in enumerate(s):\n        if char in char_dict:\n            start = max(start, char_dict[char]+1)\n        char_dict[char] = n\n        length = max(length, n - start+1)\n    return length\n</code></pre><code>class Solution:\n# @return an integer\ndef lengthOfLongestSubstring(self, s):\n    char_dict = dict()\n    start, length = 0, 0\n    for n, char in enumerate(s):\n        if char in char_dict:\n            start = max(start, char_dict[char]+1)\n        char_dict[char] = n\n        length = max(length, n - start+1)\n    return length\n</code><p>find a start position with no repeating chars</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Longest Substring Without Repeating Characters", "author_score": "20,650", "time": "2015-01-24T13:53:35+0000"}}, "answers": [], "title": "A dry python code"}, {"question": {"content": "<pre><code>class Solution:\n# @param A, a list of integers\n# @param target, an integer to be searched\n# @return a list of length 2, [index1, index2]\ndef searchRange(self, arr, target):\n    start = self.binary_search(arr, target-0.5)\n    if arr[start] != target:\n        return [-1, -1]\n    arr.append(0)\n    end = self.binary_search(arr, target+0.5)-1\n    return [start, end]\n\ndef binary_search(self, arr, target):\n    start, end = 0, len(arr)-1\n    while start &lt; end:\n        mid = (start+end)//2\n        if target &lt; arr[mid]:\n            end = mid\n        else:\n            start = mid+1\n    return start\n</code></pre><code>class Solution:\n# @param A, a list of integers\n# @param target, an integer to be searched\n# @return a list of length 2, [index1, index2]\ndef searchRange(self, arr, target):\n    start = self.binary_search(arr, target-0.5)\n    if arr[start] != target:\n        return [-1, -1]\n    arr.append(0)\n    end = self.binary_search(arr, target+0.5)-1\n    return [start, end]\n\ndef binary_search(self, arr, target):\n    start, end = 0, len(arr)-1\n    while start &lt; end:\n        mid = (start+end)//2\n        if target &lt; arr[mid]:\n            end = mid\n        else:\n            start = mid+1\n    return start\n</code><p>for search the target+0.5 position we add something whatever to the list end\n to get the right position for the edge case</p><p>take ([0,1,2,3,4,5], 5) for example:</p><p>we append 0 to the list end</p><p>[0,1,2,3,4,5,0]</p><p>[4,5,0]# start now is 4, end is 6, mid is 5,  start = mid+1 = 6, end the while loop</p><p>finally we get the 5.5 position == start == 6</p>", "votes": {"down": "0", "up": "9"}, "meta": {"author": "tusizi", "catagory": "Search for a Range", "author_score": "20,650", "time": "2015-01-22T11:35:21+0000"}, "comments": [{"content": "<p>Could you please explain more why we append a 0 in the end? Thanks! </p>", "votes": null, "meta": {"author": "zzhu06", "author_score": "900", "time": "2015-03-13T06:04:20+0000"}}]}, "answers": [{"content": "<p>This is pretty smart! Given the problem with a list of integers, +/- 0.5 will solve the problem of writing two similar binary search methods because of duplicates. Again, kudos! </p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "ningchris", "author_score": "180", "time": "2015-01-25T15:46:46+0000"}}, {"content": "<p>I made some modification with regard to Java, eliminating the part which appends elements to the end of a primitive array.</p><pre><code>public class Solution {\n    public int[] searchRange(int[] A, int target) {\n        int[] ret = new int[2];\n\n        int pos1 = myBinarySearch(A, (float)(target-0.5));\n        int pos2 = myBinarySearch(A, (float)(target+0.5));\n\n        if(A[pos1] != target) {\n            pos1 = -1;\n            pos2 = -1;\n        }\n        else if(A[pos2] != target) {\n            pos2--;\n        }\n\n        ret[0] = pos1;\n        ret[1] = pos2;\n\n        return ret;\n    }\n\n    private int myBinarySearch(int[] A, float target) {\n        // accept target of type float\n        int a = 0;\n        int b = A.length-1;\n\n        int half = 0;\n\n        while(a&lt;b) {\n            half = (a+b)/2;\n            if( A[half] &lt; target ) a = half+1;\n            else b = half;\n        }\n\n        return a;\n    }\n}\n</code></pre><code>public class Solution {\n    public int[] searchRange(int[] A, int target) {\n        int[] ret = new int[2];\n\n        int pos1 = myBinarySearch(A, (float)(target-0.5));\n        int pos2 = myBinarySearch(A, (float)(target+0.5));\n\n        if(A[pos1] != target) {\n            pos1 = -1;\n            pos2 = -1;\n        }\n        else if(A[pos2] != target) {\n            pos2--;\n        }\n\n        ret[0] = pos1;\n        ret[1] = pos2;\n\n        return ret;\n    }\n\n    private int myBinarySearch(int[] A, float target) {\n        // accept target of type float\n        int a = 0;\n        int b = A.length-1;\n\n        int half = 0;\n\n        while(a&lt;b) {\n            half = (a+b)/2;\n            if( A[half] &lt; target ) a = half+1;\n            else b = half;\n        }\n\n        return a;\n    }\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "wjhypo", "author_score": "110", "time": "2015-03-16T02:53:43+0000"}}], "title": "Search for the position target-0.5 and target+0.5, a simple python code with a little trick"}, {"question": {"content": "<pre><code>class Solution:\n# @return a list of lists of integer\ndef generateMatrix(self, n):\n    matrix = [[0]*n for _ in range(n)]\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    d = 0\n    y, x = 0, 0\n    for i in range(1, n*n+1):\n        matrix[y][x] = i\n        dy, dx = directions[d % 4]\n        if -1 &lt; y+dy &lt; n and -1 &lt; x+dx &lt; n and matrix[y+dy][x+dx] == 0:\n            y, x = y+dy, x+dx\n        else:\n            d += 1\n            dy, dx = directions[d % 4]\n            y, x = y+dy, x+dx\n    return matrix\n</code></pre><code>class Solution:\n# @return a list of lists of integer\ndef generateMatrix(self, n):\n    matrix = [[0]*n for _ in range(n)]\n    directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    d = 0\n    y, x = 0, 0\n    for i in range(1, n*n+1):\n        matrix[y][x] = i\n        dy, dx = directions[d % 4]\n        if -1 &lt; y+dy &lt; n and -1 &lt; x+dx &lt; n and matrix[y+dy][x+dx] == 0:\n            y, x = y+dy, x+dx\n        else:\n            d += 1\n            dy, dx = directions[d % 4]\n            y, x = y+dy, x+dx\n    return matrix\n</code><p>Change the direction If the we can't write to the matrix</p>", "votes": {"down": "0", "up": "4"}, "meta": {"author": "tusizi", "catagory": "Spiral Matrix II", "author_score": "20,650", "time": "2015-01-22T06:14:09+0000"}, "comments": [{"content": "<p>exactly what I thought. However, i do not figure out how to use direction elegantly.</p>", "votes": null, "meta": {"author": "hu.cao1", "author_score": "2,370", "time": "2015-03-21T04:08:54+0000"}}]}, "answers": [], "title": "If we can't write data to the matrix, we change the direction,a simple python solution"}, {"question": {"content": "<p>Though python is slow, It is easy to write</p><pre><code>class Solution:\n# @return a string\ndef fractionToDecimal(self, numerator, denominator):\n    n, remainder = divmod(abs(numerator), abs(denominator))\n    sign = '-' if numerator*denominator &lt; 0 else ''\n    result = [sign+str(n), '.']\n    stack = []\n    while remainder not in stack:\n        stack.append(remainder)\n        n, remainder = divmod(remainder*10, abs(denominator))\n        result.append(str(n))\n\n    idx = stack.index(remainder)\n    result.insert(idx+2, '(')\n    result.append(')')\n    return ''.join(result).replace('(0)', '').rstrip('.')\n</code></pre><code>class Solution:\n# @return a string\ndef fractionToDecimal(self, numerator, denominator):\n    n, remainder = divmod(abs(numerator), abs(denominator))\n    sign = '-' if numerator*denominator &lt; 0 else ''\n    result = [sign+str(n), '.']\n    stack = []\n    while remainder not in stack:\n        stack.append(remainder)\n        n, remainder = divmod(remainder*10, abs(denominator))\n        result.append(str(n))\n\n    idx = stack.index(remainder)\n    result.insert(idx+2, '(')\n    result.append(')')\n    return ''.join(result).replace('(0)', '').rstrip('.')\n</code><p>and there's no overflow</p>", "votes": {"down": "0", "up": "7"}, "meta": {"author": "tusizi", "catagory": "Fraction to Recurring Decimal", "author_score": "20,650", "time": "2015-01-21T12:02:58+0000"}, "comments": [{"content": "<p>nice solution, thanks for share.</p>", "votes": null, "meta": {"author": "LoveJenny", "author_score": "2,320", "time": "2015-02-03T03:16:04+0000"}}, {"content": "<p>Could you please explain why we need to use ''.join(result).replace('(0)', '').rstrip('.') for the result ? Thanks!</p>", "votes": null, "meta": {"author": "UmassJin", "author_score": "250", "time": "2015-03-12T05:20:26+0000"}}, {"content": "<p>Take f(6, 3) for example, ''.join(result) == 2.(0)</p><p>''.join(result).replace('(0)', '').rstrip('.') == 2</p>", "votes": null, "meta": {"author": "tusizi", "author_score": "20,650", "time": "2015-03-12T06:07:08+0000"}}, {"content": "<p>Got it! Thank you! </p>", "votes": null, "meta": {"author": "UmassJin", "author_score": "250", "time": "2015-03-12T18:44:34+0000"}}]}, "answers": [], "title": "Do not use python as cpp, here's a short version python code"}, {"question": {"content": "<pre><code>class Solution:\n    # @return a string\n    def longestCommonPrefix(self, strs):\n        prefix = strs[0] if strs else ''\n        while True:\n            if all(s.startswith(prefix) for s in strs):\n                return prefix\n            prefix = prefix[:-1]\n</code></pre><code>class Solution:\n    # @return a string\n    def longestCommonPrefix(self, strs):\n        prefix = strs[0] if strs else ''\n        while True:\n            if all(s.startswith(prefix) for s in strs):\n                return prefix\n            prefix = prefix[:-1]\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "catagory": "Longest Common Prefix", "author_score": "20,650", "time": "2015-01-18T10:47:23+0000"}}, "answers": [], "title": "short python code"}], "identifier": "tusizi", "AnswerInfo": [{"question": {"content": "<pre><code>class Solution:\n# @return a ListNode\ndef addTwoNumbers(self, l1, l2):\n    carry = 0\n    root = n = ListNode(0)\n    while l1 or l2 or carry:\n        v1 = v2 = 0\n        if l1:\n            v1 = l1.val\n            l1 = l1.next\n        if l2:\n            v2 = l2.val\n            l2 = l2.next\n        carry, val = divmod(v1+v2+carry, 10)\n        n.next = ListNode(val)\n        n = n.next\n    return root.next\n</code></pre><code>class Solution:\n# @return a ListNode\ndef addTwoNumbers(self, l1, l2):\n    carry = 0\n    root = n = ListNode(0)\n    while l1 or l2 or carry:\n        v1 = v2 = 0\n        if l1:\n            v1 = l1.val\n            l1 = l1.next\n        if l2:\n            v2 = l2.val\n            l2 = l2.next\n        carry, val = divmod(v1+v2+carry, 10)\n        n.next = ListNode(val)\n        n = n.next\n    return root.next\n</code>", "votes": {"down": "0", "up": "11"}, "meta": {"author": "tusizi", "catagory": "Add Two Numbers", "author_score": "20,650", "time": "2015-02-15T13:27:25+0000"}}, "answers": [{"content": "<p>I found this <a rel=\"nofollow\" href=\"http://stackoverflow.com/questions/11498441/what-is-this-kind-of-assignment-in-python-called-a-b-true\">Stack Overflow</a> to find out the answer.</p><a rel=\"nofollow\" href=\"http://stackoverflow.com/questions/11498441/what-is-this-kind-of-assignment-in-python-called-a-b-true\">Stack Overflow</a><p>n.next = n = ListNode(val) means first n.next = ListNode(val) then n point to the same address</p><p>n = n.next = ListNode(val) means first n = ListNode(val) , now the n is ListNode(val), then n.next point to the address ListNode(val) which means point to itself!!!</p><p>Hope this will help.</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tusizi", "author_score": "20,650", "time": "2015-03-17T09:18:08+0000"}, "best_answer": true}, {"content": "<p>You can write second last 2 lines in only one:</p><p>n.next = n = ListNode(val)</p>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "DiZ", "author_score": "570", "time": "2015-03-05T13:58:36+0000"}, "comments": [{"content": "<p>Yes, quite right, BTW, from checkio?</p>", "votes": null, "meta": {"author": "tusizi", "author_score": "20,650", "time": "2015-03-05T17:23:11+0000"}}, {"content": "<p>But this consecutive assignments is a little unclear for me, perhaps tuple assignment is better?</p>", "votes": null, "meta": {"author": "tusizi", "author_score": "20,650", "time": "2015-03-05T17:36:39+0000"}}, {"content": "<p>Shouldn't it be: n = n.next = ListNode(val)?Why?</p>", "votes": null, "meta": {"author": "plough", "author_score": "170", "time": "2015-03-17T07:08:38+0000"}}]}, {"content": "<p>nice solution! However, I think the variable v1, v2 is unnecessary.</p><pre><code> def addTwoNumbers(self, l1, l2):\n        carry = 0;\n        res = n = ListNode(0);\n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next;\n            if l2:\n                carry += l2.val;\n                l2 = l2.next;\n            carry, val = divmod(carry, 10)\n            n.next = n = ListNode(val);\n        return res.next;\n</code></pre><code> def addTwoNumbers(self, l1, l2):\n        carry = 0;\n        res = n = ListNode(0);\n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next;\n            if l2:\n                carry += l2.val;\n                l2 = l2.next;\n            carry, val = divmod(carry, 10)\n            n.next = n = ListNode(val);\n        return res.next;\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "tju_xu", "author_score": "2,380", "time": "2015-08-04T11:16:39+0000"}}], "title": "Clear python code, straight forward"}, {"question": {"content": "<pre><code>class Solution:\n    # @return a string\n    def countAndSay(self, n):\n        string = str(1)\n        while n &gt; 1:\n            count = 1\n            temp = \"\"\n            for i in range(1, len(string)):\n                if string[i] != string[i-1]:\n                    temp += str(count)\n                    temp += string[i-1]\n                    count = 1\n                else:\n                    count += 1\n            temp += str(count)\n            temp += string[-1]\n            string = temp\n            n -= 1\n        return string\n</code></pre><code>class Solution:\n    # @return a string\n    def countAndSay(self, n):\n        string = str(1)\n        while n &gt; 1:\n            count = 1\n            temp = \"\"\n            for i in range(1, len(string)):\n                if string[i] != string[i-1]:\n                    temp += str(count)\n                    temp += string[i-1]\n                    count = 1\n                else:\n                    count += 1\n            temp += str(count)\n            temp += string[-1]\n            string = temp\n            n -= 1\n        return string\n</code><p>Basically, I keep a \u201dcount\u201c variable to count the number of consecutive same characters. Once it encounters a character that's different from its previous one, I append the number of the previous consecutive character along with the previous character to the \"temp\" string and reset count to 0. After an iteration of the sequence string, if it's not the Nth sequence, continue the while loop with the updated sequence string.</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "xiaoying10101", "catagory": "Count and Say", "author_score": "4,570", "time": "2015-01-13T21:44:51+0000"}}, "answers": [{"content": "<p>Batteries Included</p><p>use itertools.groupby</p><pre><code>class Solution:\n# @return a string\ndef countAndSay(self, n):\n    res = '1'\n    for i in range(n-1):\n        stack = []\n        for (k, g) in itertools.groupby(res):\n            stack.append(str(len(list(g)))+k)\n        res = ''.join(stack)\n    return res\n</code></pre><code>class Solution:\n# @return a string\ndef countAndSay(self, n):\n    res = '1'\n    for i in range(n-1):\n        stack = []\n        for (k, g) in itertools.groupby(res):\n            stack.append(str(len(list(g)))+k)\n        res = ''.join(stack)\n    return res\n</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "tusizi", "author_score": "20,650", "time": "2015-01-18T12:15:09+0000"}}], "title": "Accpeted Python solution. Is this a good solution?"}], "UserInfo": {"voted_answer": "8", "score": "20,650", "got_upvote": "393", "comments": "10", "questions": "105", "voted_question": "19", "got_downvote": "11", "give_downvote": "0", "give_upvote": "27", "answers": "2"}}