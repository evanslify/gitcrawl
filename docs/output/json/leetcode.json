[{"AnswerInfo": [{"question": {"content": "<p>This is my iterative solution using binary search. The main idea is to find the approximate location of the median and compare the elements around it to get the final result.</p><ol>\n<li><p>do binary search. suppose the shorter list is A with length n. <strong>the runtime is O(log(n)) which means no matter how large B array is, it only depends on the size of A</strong>. It makes sense because if A has only one element while B has 100 elements, the median must be one of A[0],  B[49], and B[50] without check everything else. If A[0] &lt;= B[49], B[49] is the answer; if B[49] &lt; A[0] &lt;= B[50], A[0] is the answer; else, B[50] is the answer.</p></li>\n<li><p>After binary search, we get the approximate location of median. Now we just need to compare at most 4 elements to find the answer. This step is O(1).</p></li>\n<li><p>the same solution can be applied to find kth element of 2 sorted arrays.</p></li>\n</ol><li><p>do binary search. suppose the shorter list is A with length n. <strong>the runtime is O(log(n)) which means no matter how large B array is, it only depends on the size of A</strong>. It makes sense because if A has only one element while B has 100 elements, the median must be one of A[0],  B[49], and B[50] without check everything else. If A[0] &lt;= B[49], B[49] is the answer; if B[49] &lt; A[0] &lt;= B[50], A[0] is the answer; else, B[50] is the answer.</p></li><p>do binary search. suppose the shorter list is A with length n. <strong>the runtime is O(log(n)) which means no matter how large B array is, it only depends on the size of A</strong>. It makes sense because if A has only one element while B has 100 elements, the median must be one of A[0],  B[49], and B[50] without check everything else. If A[0] &lt;= B[49], B[49] is the answer; if B[49] &lt; A[0] &lt;= B[50], A[0] is the answer; else, B[50] is the answer.</p><strong>the runtime is O(log(n)) which means no matter how large B array is, it only depends on the size of A</strong><li><p>After binary search, we get the approximate location of median. Now we just need to compare at most 4 elements to find the answer. This step is O(1).</p></li><p>After binary search, we get the approximate location of median. Now we just need to compare at most 4 elements to find the answer. This step is O(1).</p><li><p>the same solution can be applied to find kth element of 2 sorted arrays.</p></li><p>the same solution can be applied to find kth element of 2 sorted arrays.</p><p>Here is the code:</p><pre><code>    public double findMedianSortedArrays(int A[], int B[]) {\n    int n = A.length;\n    int m = B.length;\n    // the following call is to make sure len(A) &lt;= len(B).\n    // yes, it calls itself, but at most once, shouldn't be\n    // consider a recursive solution\n    if (n &gt; m)\n        return findMedianSortedArrays(B, A);\n\n    // now, do binary search\n    int k = (n + m - 1) / 2;\n    int l = 0, r = Math.min(k, n); // r is n, NOT n-1, this is important!!\n    while (l &lt; r) {\n        int midA = (l + r) / 2;\n        int midB = k - midA;\n        if (A[midA] &lt; B[midB])\n            l = midA + 1;\n        else\n            r = midA;\n    }\n\n    // after binary search, we almost get the median because it must be between\n    // these 4 numbers: A[l-1], A[l], B[k-l], and B[k-l+1] \n\n    // if (n+m) is odd, the median is the larger one between A[l-1] and B[k-l].\n    // and there are some corner cases we need to take care of.\n    int a = Math.max(l &gt; 0 ? A[l - 1] : Integer.MIN_VALUE, k - l &gt;= 0 ? B[k - l] : Integer.MIN_VALUE);\n    if (((n + m) &amp; 1) == 1)\n        return (double) a;\n\n    // if (n+m) is even, the median can be calculated by \n    //      median = (max(A[l-1], B[k-l]) + min(A[l], B[k-l+1]) / 2.0\n    // also, there are some corner cases to take care of.\n    int b = Math.min(l &lt; n ? A[l] : Integer.MAX_VALUE, k - l + 1 &lt; m ? B[k - l + 1] : Integer.MAX_VALUE);\n    return (a + b) / 2.0;\n}\n</code></pre><code>    public double findMedianSortedArrays(int A[], int B[]) {\n    int n = A.length;\n    int m = B.length;\n    // the following call is to make sure len(A) &lt;= len(B).\n    // yes, it calls itself, but at most once, shouldn't be\n    // consider a recursive solution\n    if (n &gt; m)\n        return findMedianSortedArrays(B, A);\n\n    // now, do binary search\n    int k = (n + m - 1) / 2;\n    int l = 0, r = Math.min(k, n); // r is n, NOT n-1, this is important!!\n    while (l &lt; r) {\n        int midA = (l + r) / 2;\n        int midB = k - midA;\n        if (A[midA] &lt; B[midB])\n            l = midA + 1;\n        else\n            r = midA;\n    }\n\n    // after binary search, we almost get the median because it must be between\n    // these 4 numbers: A[l-1], A[l], B[k-l], and B[k-l+1] \n\n    // if (n+m) is odd, the median is the larger one between A[l-1] and B[k-l].\n    // and there are some corner cases we need to take care of.\n    int a = Math.max(l &gt; 0 ? A[l - 1] : Integer.MIN_VALUE, k - l &gt;= 0 ? B[k - l] : Integer.MIN_VALUE);\n    if (((n + m) &amp; 1) == 1)\n        return (double) a;\n\n    // if (n+m) is even, the median can be calculated by \n    //      median = (max(A[l-1], B[k-l]) + min(A[l], B[k-l+1]) / 2.0\n    // also, there are some corner cases to take care of.\n    int b = Math.min(l &lt; n ? A[l] : Integer.MAX_VALUE, k - l + 1 &lt; m ? B[k - l + 1] : Integer.MAX_VALUE);\n    return (a + b) / 2.0;\n}\n</code><p>I'm lazy to type. But I found a very good pdf to explain my algorithm: http://ocw.alfaisal.edu/NR/rdonlyres/Electrical-Engineering-and-Computer-Science/6-046JFall-2005/30C68118-E436-4FE3-8C79-6BAFBB07D935/0/ps9sol.pdf</p><p>BTW: Thanks to  xdxiaoxin. I've removed the check \"midB &gt; k\".</p>", "votes": {"down": "4", "up": "72"}, "meta": {"author": "tyuan73", "catagory": "Median of Two Sorted Arrays", "author_score": "8,720", "time": "2014-09-15T06:41:27+0000"}, "comments": [{"content": "<p>very nice solution!</p>", "votes": null, "meta": {"author": "zhi.huang", "author_score": "110", "time": "2014-09-16T19:17:08+0000"}}, {"content": "<p>Nice solution!!! I was thinking a similar method , but could not implement it in a tidy way.  I wrote the code in C++ (I removed the condition \"midB &gt; k\") and it passed.  But it seems to fail for array with descending order...</p>", "votes": null, "meta": {"author": "hh1985", "author_score": "2,620", "time": "2014-09-22T23:47:30+0000"}}, {"content": ["One question though: under what scenario midB > k? At that point, midA should be less than zero"], "votes": null, "meta": {"author": "xdxiaoxin", "author_score": "230", "time": "2014-11-03T05:27:28+0000"}}, {"content": "<p>Tried to implement the same algorithm in C++, yet cannot get the correct answer for arrays with duplicate values, such as A=[1,1], B=[1,2].</p>", "votes": null, "meta": {"author": "jokebill", "author_score": "160", "time": "2014-11-05T23:13:03+0000"}}, {"content": "<p>Nice program!</p>", "votes": null, "meta": {"author": "shawngao", "author_score": "290", "time": "2014-11-11T17:03:55+0000"}}, {"content": "<p>I don't understand your argument why if array A has one element, then the median should be some of A[0], B[49] and B[50]? consider the following case:\nA = {1}\nB = {2, 3, 4, 5, 6, 7}\nThen the median is element B[2] = 4? </p>", "votes": null, "meta": {"author": "SamMy89", "author_score": "1,360", "time": "2014-11-26T12:04:12+0000"}}, {"content": "<p>can you explain why  after binary search, we almost get the median because it must be between\n    // these 4 numbers: A[l-1], A[l], B[k-l], and B[k-l+1] ?</p><p>and why you need to check if m+n is odd or not?</p>", "votes": null, "meta": {"author": "bboczeng", "author_score": "2,070", "time": "2014-12-07T05:26:47+0000"}}, {"content": "<p>another thing is in the PDF solution, median is found if A[midA] &gt; B[midB] and A[midA] &lt; B[midB+1]. Why didn't you do it here... thx</p>", "votes": null, "meta": {"author": "bboczeng", "author_score": "2,070", "time": "2014-12-07T05:32:52+0000"}}]}, "answers": [{"content": "<p>Very clever code! could you elaborate on the binary search step? I have a hard time figuring out what l,r,k mean and how minA and minB are calculated from l,r,k. Thanks!</p>", "votes": {"down": "0", "up": "10"}, "meta": {"author": "cbmbbz", "author_score": "17,220", "time": "2014-11-08T23:48:22+0000"}, "comments": [{"content": "<p>I think k is the sum of l-1, k-l and 1,where A[l-1] and B[k-1] are the possible median.\nTo find the final median, it needs to search in the range [l,r].</p>", "votes": null, "meta": {"author": "h12311334", "author_score": "220", "time": "2014-12-25T13:04:08+0000"}}, {"content": "<p>r = Math.min(k, n); actually r can be directly set to n since n is always smaller than m. Hopefully r = n would help understand better. Then the while loop helps locate the mid position of A.</p>", "votes": null, "meta": {"author": "Cat818", "author_score": "-520", "time": "2015-01-08T02:58:10+0000"}}]}], "title": "share my iterative solution with O(log(min(n, m)))"}, {"question": {"content": "<pre><code>public class Solution {\n    public int minDepth(TreeNode root) {\n        if (root==null) return 0;   // height is zero\n        int leftH = minDepth(root.left);  // get left height\n        int rightH = minDepth(root.right);  // get right height\n        if (leftH*rightH==0 &amp;&amp; leftH!=rightH){  // only one of them is zero\n            return (leftH!=0?leftH:rightH)+1;     // return non-zero one\n        }\n        return Math.min(leftH,rightH)+1;  // else return the smaller one\n    }\n}\n</code></pre><code>public class Solution {\n    public int minDepth(TreeNode root) {\n        if (root==null) return 0;   // height is zero\n        int leftH = minDepth(root.left);  // get left height\n        int rightH = minDepth(root.right);  // get right height\n        if (leftH*rightH==0 &amp;&amp; leftH!=rightH){  // only one of them is zero\n            return (leftH!=0?leftH:rightH)+1;     // return non-zero one\n        }\n        return Math.min(leftH,rightH)+1;  // else return the smaller one\n    }\n}\n</code><p>Nothing special... logic is presented in the comments. </p>", "votes": {"down": "0", "up": "2"}, "meta": {"author": "Adeath", "catagory": "Minimum Depth of Binary Tree", "author_score": "2,450", "time": "2014-10-26T03:55:23+0000"}}, "answers": [{"content": "<pre><code> if (leftH*rightH==0 &amp;&amp; leftH!=rightH) \n</code></pre><code> if (leftH*rightH==0 &amp;&amp; leftH!=rightH) \n</code><p>u can try XOR instead. like:</p><pre><code>  if (leftH==0 ^ leftH==0) \n</code></pre><code>  if (leftH==0 ^ leftH==0) \n</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "cbmbbz", "author_score": "17,220", "time": "2014-11-06T08:28:27+0000"}, "comments": [{"content": "<p>Great, didn't think about that. And the second one should be rightH?</p>", "votes": null, "meta": {"author": "Adeath", "author_score": "2,450", "time": "2014-11-06T16:03:37+0000"}}]}], "title": "just share a simple recursive solution"}, {"question": {"content": "<pre><code>    public int minDepth(TreeNode root) {\n\n    if( root == null ) return 0;\n\n    if( root.left == null &amp;&amp; root.right == null ) return 1;\n\n    int a = minDepth( root.left );\n    int b = minDepth( root.right );\n\n    if( a &gt; 0 &amp;&amp; b &gt; 0 ) return Math.min(a,b)+1;\n\n    return a + b + 1;\n}\n</code></pre><code>    public int minDepth(TreeNode root) {\n\n    if( root == null ) return 0;\n\n    if( root.left == null &amp;&amp; root.right == null ) return 1;\n\n    int a = minDepth( root.left );\n    int b = minDepth( root.right );\n\n    if( a &gt; 0 &amp;&amp; b &gt; 0 ) return Math.min(a,b)+1;\n\n    return a + b + 1;\n}\n</code><p>My first code was wrong because I didn't aware of if return value is '0', then I should not use it to compare return value from left/right in Math.min, because that way you will always have 0 as minimum, 0 means we already reach the leaf's left or right. We should not consider it as the path end. What I am saying is this is wrong </p><pre><code>return Math.min( minDepth(root.left),minDepth(root.right) ) + 1;\n</code></pre><code>return Math.min( minDepth(root.left),minDepth(root.right) ) + 1;\n</code><p>for finding max depth, this should work well I think.</p>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "benjaminlin", "catagory": "Minimum Depth of Binary Tree", "author_score": "190", "time": "2014-10-30T06:51:19+0000"}}, "answers": [{"content": "<p>very good and concise code!\nbut it has to traverse all the nodes in the tree, so it may not the most efficient method...</p>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "cbmbbz", "author_score": "17,220", "time": "2014-11-06T08:07:30+0000"}}], "title": "My simple Java recursive solution"}], "QuestionInfo": [{"question": {"content": "<p>when n increases by 1, the sequence of gray code doubles -- the new half is a mirror of the old half, except the new half has the left most bit set to 1.</p><pre><code>class Solution(object):\n    def grayCode(self, n):\n        if n == 0: return [0]\n        ans = [0, 1]\n        for i in xrange(2,n+1):\n            for j in xrange(len(ans)-1, -1, -1):\n                ans.append(ans[j] | 1&lt;&lt;i-1)\n        return ans\n</code></pre><code>class Solution(object):\n    def grayCode(self, n):\n        if n == 0: return [0]\n        ans = [0, 1]\n        for i in xrange(2,n+1):\n            for j in xrange(len(ans)-1, -1, -1):\n                ans.append(ans[j] | 1&lt;&lt;i-1)\n        return ans\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "cbmbbz", "catagory": "Gray Code", "author_score": "17,220", "time": "2015-09-25T16:46:54+0000"}}, "answers": [], "title": "7-line python solution with explanation"}, {"question": {"content": "<p>H-index is at most the number of papers, which is len(citations) . keep a list of length len(citations)+1, and at each index i, record the number of papers with citations exactly i (except for the last index, which records number of papers with citations &gt;= i). After constructing such list, scan the list from the back, maintain the sum of all encountered number. The sum means how many paper with citation &gt;= the index. If sum&gt;= index, then the index is the h-index.</p><pre><code>    def hIndex(self, citations):\n        stat = [0]*(len(citations)+1)\n        for i in citations:\n            if i&gt;len(citations):\n                i = len(citations)\n            stat[i] += 1\n\n        sum = 0 \n        for j in xrange(len(citations), -1, -1):\n            sum += stat[j]\n            if sum &gt;= j:\n                return j\n        return 0\n</code></pre><code>    def hIndex(self, citations):\n        stat = [0]*(len(citations)+1)\n        for i in citations:\n            if i&gt;len(citations):\n                i = len(citations)\n            stat[i] += 1\n\n        sum = 0 \n        for j in xrange(len(citations), -1, -1):\n            sum += stat[j]\n            if sum &gt;= j:\n                return j\n        return 0\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "cbmbbz", "catagory": "H-Index", "author_score": "17,220", "time": "2015-09-07T03:47:51+0000"}}, "answers": [], "title": "simple O(N) python code with explanation"}, {"question": {"content": "<p>when adding number to the result num<em>list, make sure only numbers larger than num</em>list[-1] can be added.</p><em>list, make sure only numbers larger than num</em><pre><code>def combinationSum3(self, k, n):\n    self.ans = []\n    self.helper([], k, n)\n    return self.ans\n\ndef helper(self, num_list, k, n):\n    start = 1                                         \n    if len(num_list) &gt; 0:                             \n        start = num_list[-1]+1                        #important\n\n    if k==1:\n        if start&lt;=n&lt;=9 and n not in num_list:         #note that  start&lt;=n&lt;=9\n            num_list_copy = num_list[:]\n            num_list_copy.append(n)\n            self.ans.append(num_list_copy)\n        else:\n            return\n\n    for i in xrange(start,10):                        #note that xrange(start,10)\n        if i &gt; n:\n            return\n        num_list.append(i)\n        self.helper(num_list, k-1, n-i)\n        del num_list[-1]\n</code></pre><code>def combinationSum3(self, k, n):\n    self.ans = []\n    self.helper([], k, n)\n    return self.ans\n\ndef helper(self, num_list, k, n):\n    start = 1                                         \n    if len(num_list) &gt; 0:                             \n        start = num_list[-1]+1                        #important\n\n    if k==1:\n        if start&lt;=n&lt;=9 and n not in num_list:         #note that  start&lt;=n&lt;=9\n            num_list_copy = num_list[:]\n            num_list_copy.append(n)\n            self.ans.append(num_list_copy)\n        else:\n            return\n\n    for i in xrange(start,10):                        #note that xrange(start,10)\n        if i &gt; n:\n            return\n        num_list.append(i)\n        self.helper(num_list, k-1, n-i)\n        del num_list[-1]\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "cbmbbz", "catagory": "Combination Sum III", "author_score": "17,220", "time": "2015-08-30T04:14:05+0000"}}, "answers": [], "title": "40ms python code, recursive, easy to understand"}, {"question": {"content": "<p>maintain two hashSets, one records the 10-letter substrings when scanning the input string, \nthe other stores the strings that are already in the result.</p><p>need to convert string to integer to reduce memory used. \nSince there are only four possible characters in string, I can use a 4-based integer to represent each string.</p><p>one tricky thing: do not write comments outside the class, or u will get Memory Limit Exceeded. </p><pre><code>public List&lt;String&gt; findRepeatedDnaSequences(String s) {\n    List&lt;String&gt; ans = new ArrayList&lt;&gt;();\n    int len = s.length();\n    HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();\n    HashSet&lt;Integer&gt; res = new HashSet&lt;&gt;(); \n    for (int i = 10; i&lt;= len; ++i){\n        String sub = s.substring(i-10,i);\n        int n = convert(sub);\n        if (!res.contains(n)){\n            if (!set.contains(n))\n                set.add(n);\n            else{\n                ans.add(sub);\n                res.add(n);   \n            }\n        }\n    }\n    return ans;\n}\n\npublic static int convert (String sub){\n    int res = 0;\n    HashMap&lt;Character, Integer&gt; dict = new HashMap&lt;&gt;();\n    dict.put('A',0); dict.put('C',1);\n    dict.put('G',2); dict.put('T',3);\n    for (int i = 0; i&lt; 10; ++i ){\n        res+=dict.get(sub.charAt(i)); \n        res*=4;\n    }\n    return res;\n}\n</code></pre><code>public List&lt;String&gt; findRepeatedDnaSequences(String s) {\n    List&lt;String&gt; ans = new ArrayList&lt;&gt;();\n    int len = s.length();\n    HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();\n    HashSet&lt;Integer&gt; res = new HashSet&lt;&gt;(); \n    for (int i = 10; i&lt;= len; ++i){\n        String sub = s.substring(i-10,i);\n        int n = convert(sub);\n        if (!res.contains(n)){\n            if (!set.contains(n))\n                set.add(n);\n            else{\n                ans.add(sub);\n                res.add(n);   \n            }\n        }\n    }\n    return ans;\n}\n\npublic static int convert (String sub){\n    int res = 0;\n    HashMap&lt;Character, Integer&gt; dict = new HashMap&lt;&gt;();\n    dict.put('A',0); dict.put('C',1);\n    dict.put('G',2); dict.put('T',3);\n    for (int i = 0; i&lt; 10; ++i ){\n        res+=dict.get(sub.charAt(i)); \n        res*=4;\n    }\n    return res;\n}\n</code>", "votes": {"down": "0", "up": "5"}, "meta": {"author": "cbmbbz", "catagory": "Repeated DNA Sequences", "author_score": "17,220", "time": "2015-03-29T22:21:43+0000"}, "comments": [{"content": "<p>How can you be sure that 2 strings won't end up returning the same int for your convert method?</p>", "votes": null, "meta": {"author": "km13818", "author_score": "100", "time": "2015-04-07T19:05:43+0000"}}, {"content": "<p>imagine some outer space alians' DNA has 10 kinds of bases (letters), like ABCDEFGHIJ, you can just convert each letter to digits and represent the string with a number, eg. \"0123456789\", without any confusion, and this is just a normal 10-based number. Now similarly, the human DNA has 4 kinds of letter, you can use a 4-based number to represent a sequence, e.g. \"0123012301\". Here each digit represents a letter at that position, so the numeric string is unique for each distinct DNA-sequence. Then , we convert this 4-based number to the int type supported by java, and this is also a one-to-one mapping. So my method has no problem encoding the DNA sequence.</p>", "votes": null, "meta": {"author": "cbmbbz", "author_score": "17,220", "time": "2015-04-14T00:25:56+0000"}}, {"content": "<p>Hi,\nWhat about overlapping sequences? it seems that your solution does not take into account this kind of sequences :\nAAATTTAAAATTTAAAA\nyour method return [AAATTTAAAA]\nIt is actually not precised in the problem, but I think overlapping strings should not be contained into the result</p>", "votes": null, "meta": {"author": "gmonnier", "author_score": "100", "time": "2015-04-14T17:33:44+0000"}}, {"content": "<p>this problem is designed to contain the overlapping sequences. </p>", "votes": null, "meta": {"author": "cbmbbz", "author_score": "17,220", "time": "2015-04-14T18:06:50+0000"}}, {"content": "<p>Thank you so much. You explained very well.</p>", "votes": null, "meta": {"author": "sandyqi0920", "author_score": "390", "time": "2015-04-16T14:52:06+0000"}}, {"content": "<p>I just got MLE error when I ran this code.</p>", "votes": null, "meta": {"author": "san89kalp", "author_score": "980", "time": "2015-08-28T05:50:25+0000"}}]}, "answers": [{"content": "<p>I still get memory limit exceeded without any comments. Using integers does save some space. Apparently not enough...</p>", "votes": {"down": "2", "up": "0"}, "meta": {"author": "qgambit2", "author_score": "5,270", "time": "2015-04-19T14:44:41+0000"}, "comments": [{"content": "<p>Use one map instead of two sets will do the trick</p>", "votes": null, "meta": {"author": "kennethliaoke", "author_score": "460", "time": "2015-07-04T05:17:49+0000"}}]}], "title": "simple java solution using hashset and 4-based int"}, {"question": {"content": "<p>It is DFS. Note that the val in root can be negative. </p><pre><code>public class Solution {\n    static List&lt;List&lt;Integer&gt;&gt; ans;\n    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {\n        ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();\n        helper (new LinkedList&lt;Integer&gt;(),root,sum);\n        return ans;\n    }\n\n    public static void helper  (List&lt;Integer&gt; l , TreeNode root, int sum){\n        if (root ==null) return;\n        l.add(root.val);\n        if (root.left==null &amp;&amp; root.right==null &amp;&amp; root.val==sum){\n            ans.add(new LinkedList&lt;Integer&gt;(l));\n        }else{\n            helper (l,root.left,sum-root.val);\n            helper (l,root.right,sum-root.val);\n        }\n        l.remove(l.size()-1);\n    }\n}\n</code></pre><code>public class Solution {\n    static List&lt;List&lt;Integer&gt;&gt; ans;\n    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {\n        ans = new LinkedList&lt;List&lt;Integer&gt;&gt;();\n        helper (new LinkedList&lt;Integer&gt;(),root,sum);\n        return ans;\n    }\n\n    public static void helper  (List&lt;Integer&gt; l , TreeNode root, int sum){\n        if (root ==null) return;\n        l.add(root.val);\n        if (root.left==null &amp;&amp; root.right==null &amp;&amp; root.val==sum){\n            ans.add(new LinkedList&lt;Integer&gt;(l));\n        }else{\n            helper (l,root.left,sum-root.val);\n            helper (l,root.right,sum-root.val);\n        }\n        l.remove(l.size()-1);\n    }\n}\n</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "cbmbbz", "catagory": "Path Sum II", "author_score": "17,220", "time": "2015-02-02T06:41:53+0000"}}, "answers": [], "title": "neat recursive Java solution. 285ms."}, {"question": {"content": "<p>the basic idea is, keep a hashmap which stores the characters in string as keys and their positions as values, and keep two pointers which define the max substring. move the right pointer to scan through the string , and meanwhile update the hashmap. If the character is already in the hashmap, then move the left pointer to the right of the same character last found. Note that the two pointers can only move forward. </p><pre><code>   public int lengthOfLongestSubstring(String s) {\n        if (s.length()==0) return 0;\n        HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();\n        int max=0;\n        for (int i=0, j=0; i&lt;s.length(); ++i){\n            if (map.containsKey(s.charAt(i))){\n                j = Math.max(j,map.get(s.charAt(i))+1);\n            }\n            map.put(s.charAt(i),i);\n            max = Math.max(max,i-j+1);\n        }\n        return max;\n    }\n</code></pre><code>   public int lengthOfLongestSubstring(String s) {\n        if (s.length()==0) return 0;\n        HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();\n        int max=0;\n        for (int i=0, j=0; i&lt;s.length(); ++i){\n            if (map.containsKey(s.charAt(i))){\n                j = Math.max(j,map.get(s.charAt(i))+1);\n            }\n            map.put(s.charAt(i),i);\n            max = Math.max(max,i-j+1);\n        }\n        return max;\n    }\n</code>", "votes": {"down": "2", "up": "76"}, "meta": {"author": "cbmbbz", "catagory": "Longest Substring Without Repeating Characters", "author_score": "17,220", "time": "2015-02-01T03:05:51+0000"}, "comments": [{"content": "<p>Hi, can you explain this line please:\nj = Math.max(j,map.get(s.charAt(i))+1);\nI cannot figure why you need to move this pointer (j) to either j or to the position of the last found repeating character.\nMany thanks!</p>", "votes": null, "meta": {"author": "ldthu", "author_score": "900", "time": "2015-02-16T17:43:02+0000"}}, {"content": "<p>The variable \"j\" is used to indicate the index of first character of this substring. If the repeated character's index is less than j itself, which means the repeated character in the hash map is no longer available this time</p>", "votes": null, "meta": {"author": "terry77228", "author_score": "100", "time": "2015-02-19T15:38:28+0000"}}, {"content": "<p>this is genious</p>", "votes": null, "meta": {"author": "freddykyang", "author_score": "370", "time": "2015-03-25T08:12:14+0000"}}, {"content": "<p>to move the left pointer to the left of the same character last found, or to move the left pointer to the right(next position) of the same character last found?</p>", "votes": null, "meta": {"author": "lindaxia2001", "author_score": "100", "time": "2015-08-11T22:16:56+0000"}}, {"content": "<p>agree, should be move the left pointer to the right of the same char last found</p>", "votes": null, "meta": {"author": "marcusgao", "author_score": "100", "time": "2015-09-05T11:57:02+0000"}}, {"content": "<p>thanks @lindaxia2001 and @marcusgao for pointing that out. It was a typo.</p>", "votes": null, "meta": {"author": "cbmbbz", "author_score": "17,220", "time": "2015-09-06T05:59:11+0000"}}]}, "answers": [{"content": "<p>I think there is no need to update <code>longest</code> evey time:</p><code>longest</code><pre><code>class Solution {\npublic:\n    int lengthOfLongestSubstring(std::string s) {\n        std::vector&lt;int&gt; flag(256, -1);\n        int start = 0, longest = 0, len = s.size();\n        for (int i = 0; i != len; ++i) {\n            if (flag[s[i]] &gt;= start) {\n                longest = std::max(longest, i - start);\n                start = flag[s[i]] + 1;\n            }\n            flag[s[i]] = i;\n        }\n        return std::max(longest, len - start);\n    }\n};\n</code></pre><code>class Solution {\npublic:\n    int lengthOfLongestSubstring(std::string s) {\n        std::vector&lt;int&gt; flag(256, -1);\n        int start = 0, longest = 0, len = s.size();\n        for (int i = 0; i != len; ++i) {\n            if (flag[s[i]] &gt;= start) {\n                longest = std::max(longest, i - start);\n                start = flag[s[i]] + 1;\n            }\n            flag[s[i]] = i;\n        }\n        return std::max(longest, len - start);\n    }\n};\n</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "prime_tang", "author_score": "16,260", "time": "2015-07-07T02:09:01+0000"}}, {"content": "<pre><code>public int lengthOfLongestSubstring(String s) {\n    int[] arr= new int[256];\n\n    int record = 0;\n    if (s != null &amp;&amp; s.length() &gt; 0)\n        record = 1;\n    else\n        return 0;\n    int lastIndex =0;\n    for (int i = 0; i &lt; s.length(); i++) {\n            int code = (int)s.charAt(i);\n\n        if (arr[code] != 0 ) {\n            int index = arr[code]-1;\n            int len =i -lastIndex;\n            if(len &gt;record) record =len;\n            if(index &gt;= lastIndex)\n            lastIndex = index+1;\n        } \n        arr[code] =i+1;\n    }\n    if(s.length()- lastIndex &gt;record) record =s.length() - lastIndex ;\n\n    return record;\n}\n</code></pre><code>public int lengthOfLongestSubstring(String s) {\n    int[] arr= new int[256];\n\n    int record = 0;\n    if (s != null &amp;&amp; s.length() &gt; 0)\n        record = 1;\n    else\n        return 0;\n    int lastIndex =0;\n    for (int i = 0; i &lt; s.length(); i++) {\n            int code = (int)s.charAt(i);\n\n        if (arr[code] != 0 ) {\n            int index = arr[code]-1;\n            int len =i -lastIndex;\n            if(len &gt;record) record =len;\n            if(index &gt;= lastIndex)\n            lastIndex = index+1;\n        } \n        arr[code] =i+1;\n    }\n    if(s.length()- lastIndex &gt;record) record =s.length() - lastIndex ;\n\n    return record;\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "taowcdl", "author_score": "130", "time": "2015-04-22T06:20:01+0000"}}, {"content": "<p>this is not O(n) as we have the complexity of searching in hashmap</p>", "votes": {"down": "36", "up": "2"}, "meta": {"author": "rabeehk", "author_score": "-720", "time": "2015-02-10T23:54:56+0000"}, "comments": [{"content": "<p>Hashmap has O(n) complexity in worse cases, so the total complexity is still O(n)</p>", "votes": null, "meta": {"author": "terry77228", "author_score": "100", "time": "2015-02-19T12:28:18+0000"}}, {"content": "<p>But you will use hashmap to search n times.</p>", "votes": null, "meta": {"author": "jywangkeep", "author_score": "180", "time": "2015-03-01T03:42:39+0000"}}, {"content": "<p>Hashmap search in O(1)</p>", "votes": null, "meta": {"author": "qjin", "author_score": "70", "time": "2015-03-25T21:48:50+0000"}}]}], "title": "11-line simple Java solution, O(n) with explanation"}, {"question": {"content": "<p>compare half of the digits in x, so don't need to deal with overflow.</p><pre><code>public boolean isPalindrome(int x) {\n    if (x&lt;0 || (x!=0 &amp;&amp; x%10==0)) return false;\n    int rev = 0;\n    while (x&gt;rev){\n        rev = rev*10 + x%10;\n        x = x/10;\n    }\n    return (x==rev || x==rev/10);\n}\n</code></pre><code>public boolean isPalindrome(int x) {\n    if (x&lt;0 || (x!=0 &amp;&amp; x%10==0)) return false;\n    int rev = 0;\n    while (x&gt;rev){\n        rev = rev*10 + x%10;\n        x = x/10;\n    }\n    return (x==rev || x==rev/10);\n}\n</code>", "votes": {"down": "0", "up": "69"}, "meta": {"author": "cbmbbz", "catagory": "Palindrome Number", "author_score": "17,220", "time": "2015-01-29T03:45:50+0000"}, "comments": [{"content": "<p>x==rev is for the scenery of even digits, x==rev/10 for the odd digits.</p>", "votes": null, "meta": {"author": "leetcode_damon", "author_score": "100", "time": "2015-05-28T03:38:55+0000"}}, {"content": "<p>Can anyone explain what the overflow problem is here?</p>", "votes": null, "meta": {"author": "zizizi", "author_score": "160", "time": "2015-06-28T03:04:28+0000"}}, {"content": "<p>leetcode_damon is correct. The point is that x is changing.</p>", "votes": null, "meta": {"author": "yan46", "author_score": "100", "time": "2015-07-16T18:53:33+0000"}}, {"content": "<p>make a friend?\u2192_\u2192</p>", "votes": null, "meta": {"author": "leetcode_damon", "author_score": "100", "time": "2015-07-17T01:59:00+0000"}}, {"content": "<p>You used extra space when you define the variable int rev=0, no? </p>", "votes": null, "meta": {"author": "psnr", "author_score": "160", "time": "2015-09-21T14:56:06+0000"}}]}, "answers": [{"content": "<p>Hi guys. I just don't know why we need to concern the overflow. When the reversed number overflows, it will becomes negative number which will return false when compared with  x.\nHere is my AC code. </p><pre><code>public class Solution {\n    public boolean isPalindrome(int x) {\n        if(x &lt; 0) return false;\n        int y = x;\n        int res = 0;\n        while(y != 0) {\n            res = res * 10 + y % 10;\n            y /= 10;\n        }\n        return x == res;\n    }\n}\n</code></pre><code>public class Solution {\n    public boolean isPalindrome(int x) {\n        if(x &lt; 0) return false;\n        int y = x;\n        int res = 0;\n        while(y != 0) {\n            res = res * 10 + y % 10;\n            y /= 10;\n        }\n        return x == res;\n    }\n}\n</code>", "votes": {"down": "1", "up": "6"}, "meta": {"author": "wen587sort", "author_score": "2,120", "time": "2015-05-28T03:18:34+0000"}, "comments": [{"content": "<p>Haha, great idea! Overflow becomes a good thing :-)</p>", "votes": null, "meta": {"author": "jianchao.li.fighter", "author_score": "53,420", "time": "2015-08-15T07:38:25+0000"}}, {"content": "<p>Overflow does not guarantee to be negative. Think about 2147483647 *3 is also positive. </p>", "votes": null, "meta": {"author": "Felix_Lou", "author_score": "90", "time": "2015-09-04T22:09:08+0000"}}]}], "title": "9-line accepted Java code, without the need of handling overflow"}, {"question": {"content": "<p>My idea is, first concat the tail to the head, building a cycle, then decide where to break the cycle to get the resulting list. The advantage of the method is, you dont need to worry about n being larger than the length of the list.</p><pre><code>   public ListNode rotateRight(ListNode head, int n) {\n        if (head == null) return null;\n        ListNode tail = head;                       //first, build a cycle\n        while (tail.next != null){\n            tail = tail.next;\n        }\n        tail.next = head;                          //cycle built.\n        ListNode fast = head, slow = head;         //now find where to break the cycle\n        while (n--&gt;0){\n            fast = fast.next;                      //move the fast runner first\n        }\n        while (fast!=tail){\n            fast = fast.next;                      //then move the fast and the slow runners together\n            slow = slow.next;\n        }\n        head = slow.next;                          //break the cycle at after the slow runner\n        slow.next = null;\n        return head;                              // return the new head\n    }\n</code></pre><code>   public ListNode rotateRight(ListNode head, int n) {\n        if (head == null) return null;\n        ListNode tail = head;                       //first, build a cycle\n        while (tail.next != null){\n            tail = tail.next;\n        }\n        tail.next = head;                          //cycle built.\n        ListNode fast = head, slow = head;         //now find where to break the cycle\n        while (n--&gt;0){\n            fast = fast.next;                      //move the fast runner first\n        }\n        while (fast!=tail){\n            fast = fast.next;                      //then move the fast and the slow runners together\n            slow = slow.next;\n        }\n        head = slow.next;                          //break the cycle at after the slow runner\n        slow.next = null;\n        return head;                              // return the new head\n    }\n</code>", "votes": {"down": "2", "up": "5"}, "meta": {"author": "cbmbbz", "catagory": "Rotate List", "author_score": "17,220", "time": "2015-01-27T22:51:27+0000"}, "comments": [{"content": "<p>there is no meaning using a circle, just move the \"fast\" by n%length steps and you'll get the same result.</p>", "votes": null, "meta": {"author": "siyang3", "author_score": "11,210", "time": "2015-02-02T07:42:31+0000"}}, {"content": "<p>Indeed, forming a circle doesn't directly help the problem here. But we always need to connect the tail to the original head sometimes(?)</p>", "votes": null, "meta": {"author": "weijiang2009", "author_score": "120", "time": "2015-04-16T09:36:25+0000"}}]}, "answers": [{"content": "<p>smart solution and easy to implement</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "chriszhaotrojan", "author_score": "90", "time": "2015-01-30T00:59:28+0000"}}], "title": "simple java solution with explanation"}, {"question": {"content": "<p>the basic idea is to maintain two queues, the first one stores all nodes with val less than x , and the second queue stores all the rest nodes. Then concat these two queues. Remember to set the tail of second queue a null next, or u will get TLE.</p><pre><code>public ListNode partition(ListNode head, int x) {\n    ListNode dummy1 = new ListNode(0), dummy2 = new ListNode(0);  //dummy heads of the 1st and 2nd queues\n    ListNode curr1 = dummy1, curr2 = dummy2;      //current tails of the two queues;\n    while (head!=null){\n        if (head.val&lt;x) {\n            curr1.next = head;\n            curr1 = head;\n        }else {\n            curr2.next = head;\n            curr2 = head;\n        }\n        head = head.next;\n    }\n    curr2.next = null;          //important! avoid cycle in linked list. otherwise u will get TLE.\n    curr1.next = dummy2.next;\n    return dummy1.next;\n}\n</code></pre><code>public ListNode partition(ListNode head, int x) {\n    ListNode dummy1 = new ListNode(0), dummy2 = new ListNode(0);  //dummy heads of the 1st and 2nd queues\n    ListNode curr1 = dummy1, curr2 = dummy2;      //current tails of the two queues;\n    while (head!=null){\n        if (head.val&lt;x) {\n            curr1.next = head;\n            curr1 = head;\n        }else {\n            curr2.next = head;\n            curr2 = head;\n        }\n        head = head.next;\n    }\n    curr2.next = null;          //important! avoid cycle in linked list. otherwise u will get TLE.\n    curr1.next = dummy2.next;\n    return dummy1.next;\n}\n</code>", "votes": {"down": "0", "up": "24"}, "meta": {"author": "cbmbbz", "catagory": "Partition List", "author_score": "17,220", "time": "2015-01-23T08:30:53+0000"}}, "answers": [{"content": "<p>sorry, still not getting why need this?\ncurr2.next = null;  </p><p>cur2 is already pointing to the last node of the origin list, which means cur.next =null should always guarantee.</p><p>so why needing this?</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "weiyi3", "author_score": "250", "time": "2015-03-25T17:26:24+0000"}, "comments": [{"content": "<p>For this list: 5-&gt;6-&gt;1-&gt;2, x=3, at last cur2 points to 6, cur1 points to 2, we must set  6-&gt;1 to 6-&gt;null, otherwise there will be a cycle.</p>", "votes": null, "meta": {"author": "zealot", "author_score": "600", "time": "2015-04-26T22:19:53+0000"}}, {"content": "<p>Very brilliant, thanks very much for pointing out this case. </p>", "votes": null, "meta": {"author": "emilie1027", "author_score": "100", "time": "2015-08-15T02:11:46+0000"}}]}], "title": "Concise java code with explanation, one pass"}, {"question": {"content": "<p>basically same as combination Sum I, but the test cases in this question have duplicates. So we need to add a line to handle that. See comment .</p><pre><code>public static List&lt;List&lt;Integer&gt;&gt; ans; \n\npublic static List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {\n    ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    List&lt;Integer&gt; l0 = new ArrayList&lt;Integer&gt;();\n    Arrays.sort(candidates);\n    findNext(candidates, target, -1, l0);\n    return ans;\n}\n\nstatic void findNext (int[] candidates, int target, int lastIdx, List&lt;Integer&gt; l ){\n    if (target == 0) {\n        ans.add(l);\n        return;\n    }\n\n    for (int i = lastIdx+1; i&lt; candidates.length; ++i){\n        if (target - candidates[i] &lt;0) return;  \n        if (i&gt;lastIdx+1 &amp;&amp; candidates[i-1]==candidates[i])  //handle duplicates\n            continue;\n        List&lt;Integer&gt; curr = new ArrayList&lt;Integer&gt;(l);\n        curr.add(candidates[i]);\n        findNext(candidates, target-candidates[i], i, curr);\n    }\n}\n</code></pre><code>public static List&lt;List&lt;Integer&gt;&gt; ans; \n\npublic static List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {\n    ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    List&lt;Integer&gt; l0 = new ArrayList&lt;Integer&gt;();\n    Arrays.sort(candidates);\n    findNext(candidates, target, -1, l0);\n    return ans;\n}\n\nstatic void findNext (int[] candidates, int target, int lastIdx, List&lt;Integer&gt; l ){\n    if (target == 0) {\n        ans.add(l);\n        return;\n    }\n\n    for (int i = lastIdx+1; i&lt; candidates.length; ++i){\n        if (target - candidates[i] &lt;0) return;  \n        if (i&gt;lastIdx+1 &amp;&amp; candidates[i-1]==candidates[i])  //handle duplicates\n            continue;\n        List&lt;Integer&gt; curr = new ArrayList&lt;Integer&gt;(l);\n        curr.add(candidates[i]);\n        findNext(candidates, target-candidates[i], i, curr);\n    }\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "cbmbbz", "catagory": "Combination Sum II", "author_score": "17,220", "time": "2014-12-30T08:54:29+0000"}}, "answers": [{"content": "<p>making an arraylist every time in recursion?</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "mmhu", "author_score": "110", "time": "2015-01-15T04:48:51+0000"}}], "title": "my accepted recursive Java solution"}, {"question": {"content": "<p>the basic idea is, to permute n numbers, we can add the nth number into the resulting <code>List&lt;List&lt;Integer&gt;&gt;</code> from the n-1 numbers, in every possible position. </p><code>List&lt;List&lt;Integer&gt;&gt;</code><p>For example, if the input num[] is {1,2,3}: First, add 1 into the initial <code>List&lt;List&lt;Integer&gt;&gt;</code> (let's call it \"answer\"). </p><code>List&lt;List&lt;Integer&gt;&gt;</code><p>Then, 2 can be added in front or after 1. So we have to copy the List in answer (it's just {1}), add 2 in position 0 of {1}, then copy the original {1} again, and add 2 in position 1. Now we have an answer of {{2,1},{1,2}}. There are 2 lists in the current answer.</p><p>Then we have to add 3. first copy {2,1} and {1,2}, add 3 in position 0; then copy {2,1} and {1,2}, and add 3 into position 1, then do the same thing for position 3. Finally we have 2*3=6 lists in answer, which is what we want.</p><pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) {\n    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    if (num.length ==0) return ans;\n    List&lt;Integer&gt; l0 = new ArrayList&lt;Integer&gt;();\n    l0.add(num[0]);\n    ans.add(l0);\n    for (int i = 1; i&lt; num.length; ++i){\n        List&lt;List&lt;Integer&gt;&gt; new_ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); \n        for (int j = 0; j&lt;=i; ++j){            \n           for (List&lt;Integer&gt; l : ans){\n               List&lt;Integer&gt; new_l = new ArrayList&lt;Integer&gt;(l);\n               new_l.add(j,num[i]);\n               new_ans.add(new_l);\n           }\n        }\n        ans = new_ans;\n    }\n    return ans;\n}\n</code></pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) {\n    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    if (num.length ==0) return ans;\n    List&lt;Integer&gt; l0 = new ArrayList&lt;Integer&gt;();\n    l0.add(num[0]);\n    ans.add(l0);\n    for (int i = 1; i&lt; num.length; ++i){\n        List&lt;List&lt;Integer&gt;&gt; new_ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); \n        for (int j = 0; j&lt;=i; ++j){            \n           for (List&lt;Integer&gt; l : ans){\n               List&lt;Integer&gt; new_l = new ArrayList&lt;Integer&gt;(l);\n               new_l.add(j,num[i]);\n               new_ans.add(new_l);\n           }\n        }\n        ans = new_ans;\n    }\n    return ans;\n}\n</code>", "votes": {"down": "0", "up": "26"}, "meta": {"author": "cbmbbz", "catagory": "Permutations", "author_score": "17,220", "time": "2014-12-26T03:59:39+0000"}}, "answers": [{"content": "<p>I used your idea of adding each next value to every possible position of current list, but have done it with recursion.</p><pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {\n    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    if (nums.length == 0) return result;\n\n    backtrack(result, nums, new ArrayList&lt;Integer&gt;(), 0);\n\n    return result;\n}\n\nprivate void backtrack(List&lt;List&lt;Integer&gt;&gt; result, int[] nums, List&lt;Integer&gt; currentList, int index) {\n    if (currentList.size() == nums.length) {\n        result.add(currentList);\n        return;\n    }\n\n    int n = nums[index];\n    for (int i = 0; i &lt;= currentList.size(); i++) {\n        List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;(currentList);\n        copy.add(i, n);\n        backtrack(result, nums, copy, index + 1);\n    }\n\n\n}\n</code></pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {\n    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    if (nums.length == 0) return result;\n\n    backtrack(result, nums, new ArrayList&lt;Integer&gt;(), 0);\n\n    return result;\n}\n\nprivate void backtrack(List&lt;List&lt;Integer&gt;&gt; result, int[] nums, List&lt;Integer&gt; currentList, int index) {\n    if (currentList.size() == nums.length) {\n        result.add(currentList);\n        return;\n    }\n\n    int n = nums[index];\n    for (int i = 0; i &lt;= currentList.size(); i++) {\n        List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;(currentList);\n        copy.add(i, n);\n        backtrack(result, nums, copy, index + 1);\n    }\n\n\n}\n</code><p>I guess both solutions have the same complexity</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "heroes3001", "author_score": "130", "time": "2015-08-25T07:49:21+0000"}, "comments": [{"content": "<p>Very nice solution! you can simply a little bit by removing a couple of lines:</p><pre><code>    public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) {\n    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    if (num.length ==0) \n        return ans;\n    ans.add(new ArrayList&lt;Integer&gt;());\n    for (int i = 0; i&lt; num.length; ++i){\n        List&lt;List&lt;Integer&gt;&gt; new_ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); \n        for (int j = 0; j&lt;=i; ++j){            \n           for (List&lt;Integer&gt; l : ans){\n               List&lt;Integer&gt; new_l = new ArrayList&lt;Integer&gt;(l);\n               new_l.add(j,num[i]);\n               new_ans.add(new_l);\n           }\n        }\n        ans = new_ans;\n    }\n    return ans;\n}\n</code></pre><code>    public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) {\n    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    if (num.length ==0) \n        return ans;\n    ans.add(new ArrayList&lt;Integer&gt;());\n    for (int i = 0; i&lt; num.length; ++i){\n        List&lt;List&lt;Integer&gt;&gt; new_ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); \n        for (int j = 0; j&lt;=i; ++j){            \n           for (List&lt;Integer&gt; l : ans){\n               List&lt;Integer&gt; new_l = new ArrayList&lt;Integer&gt;(l);\n               new_l.add(j,num[i]);\n               new_ans.add(new_l);\n           }\n        }\n        ans = new_ans;\n    }\n    return ans;\n}\n</code>", "votes": null, "meta": {"author": "jinwu", "author_score": "5,150", "time": "2015-08-31T02:35:07+0000"}}]}], "title": "my AC simple iterative java solution"}, {"question": {"content": "<p>the basic idea is to make three cuts into the string, separating it into four parts, each part contains 1~3 digits and it must be &lt;255. </p><pre><code>static List&lt;String&gt; restoreIpAddresses(String s) {\n    List&lt;String&gt; ans = new ArrayList&lt;String&gt;();\n    int len = s.length();\n    for (int i = 1; i &lt;=3; ++i){  // first cut\n        if (len-i &gt; 9) continue;            \n        for (int j = i+1; j&lt;=i+3; ++j){  //second cut\n            if (len-j &gt; 6) continue;                \n            for (int k = j+1; k&lt;=j+3 &amp;&amp; k&lt;len; ++k){  // third cut\n                int a,b,c,d;                // the four int's seperated by \".\"\n                a = Integer.parseInt(s.substring(0,i));  \n                b = Integer.parseInt(s.substring(i,j)); // notice that \"01\" can be parsed into 1. Need to deal with that later.\n                c = Integer.parseInt(s.substring(j,k));\n                d = Integer.parseInt(s.substring(k));\n                if (a&gt;255 || b&gt;255 || c&gt;255 || d&gt;255) continue; \n                String ip = a+\".\"+b+\".\"+c+\".\"+d;\n                if (ip.length()&lt;len+3) continue;  // this is to reject those int's parsed from \"01\" or \"00\"-like substrings\n                ans.add(ip);\n            }\n        }\n    }\n    return ans;\n}\n</code></pre><code>static List&lt;String&gt; restoreIpAddresses(String s) {\n    List&lt;String&gt; ans = new ArrayList&lt;String&gt;();\n    int len = s.length();\n    for (int i = 1; i &lt;=3; ++i){  // first cut\n        if (len-i &gt; 9) continue;            \n        for (int j = i+1; j&lt;=i+3; ++j){  //second cut\n            if (len-j &gt; 6) continue;                \n            for (int k = j+1; k&lt;=j+3 &amp;&amp; k&lt;len; ++k){  // third cut\n                int a,b,c,d;                // the four int's seperated by \".\"\n                a = Integer.parseInt(s.substring(0,i));  \n                b = Integer.parseInt(s.substring(i,j)); // notice that \"01\" can be parsed into 1. Need to deal with that later.\n                c = Integer.parseInt(s.substring(j,k));\n                d = Integer.parseInt(s.substring(k));\n                if (a&gt;255 || b&gt;255 || c&gt;255 || d&gt;255) continue; \n                String ip = a+\".\"+b+\".\"+c+\".\"+d;\n                if (ip.length()&lt;len+3) continue;  // this is to reject those int's parsed from \"01\" or \"00\"-like substrings\n                ans.add(ip);\n            }\n        }\n    }\n    return ans;\n}\n</code>", "votes": {"down": "0", "up": "18"}, "meta": {"author": "cbmbbz", "catagory": "Restore IP Addresses", "author_score": "17,220", "time": "2014-12-24T00:36:05+0000"}}, "answers": [], "title": "my concise AC java code"}, {"question": {"content": "<p>the main idea is work from the outermost edges to the middle of the matrix.\none tricky thing is dealing with the parity of n -- see the comment for details</p><pre><code>public int[][] generateMatrix(int n) {\n    int[][] ans = new int[n][n];\n    int curr = 1;\n    for (int i = 0, j = 0; i&lt;(n+1)/2 ; ++i, ++j){\n        for (int k = j; k&lt;n-j; ++k){\n            ans[i][k] = curr++;\n        }\n        if (i&gt;=n/2) break;  // this is needed for odd n's.\n        for (int k = i+1; k&lt;n-1-i; ++k){\n            ans[k][n-1-j]=curr++;\n        }\n        for (int k = n-1-j; k&gt;j; --k){\n            ans[n-1-i][k] = curr++;\n        }\n        for (int k = n-1-i; k&gt;i; --k){\n            ans[k][j] = curr++;\n        }\n    }\n\n    return ans;\n}\n</code></pre><code>public int[][] generateMatrix(int n) {\n    int[][] ans = new int[n][n];\n    int curr = 1;\n    for (int i = 0, j = 0; i&lt;(n+1)/2 ; ++i, ++j){\n        for (int k = j; k&lt;n-j; ++k){\n            ans[i][k] = curr++;\n        }\n        if (i&gt;=n/2) break;  // this is needed for odd n's.\n        for (int k = i+1; k&lt;n-1-i; ++k){\n            ans[k][n-1-j]=curr++;\n        }\n        for (int k = n-1-j; k&gt;j; --k){\n            ans[n-1-i][k] = curr++;\n        }\n        for (int k = n-1-i; k&gt;i; --k){\n            ans[k][j] = curr++;\n        }\n    }\n\n    return ans;\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "cbmbbz", "catagory": "Spiral Matrix II", "author_score": "17,220", "time": "2014-12-21T05:23:38+0000"}}, "answers": [], "title": "my AC simple java solution"}, {"question": {"content": "<p>The basic idea is pass the min and max value to the children, and keep updating the min and max values.\nI used (long) to address overflow.</p><pre><code>public boolean isValidBST(TreeNode root) {\n    return isValidBST_recur(root, Integer.MIN_VALUE-1L, Integer.MAX_VALUE+1L) &amp;&amp; isValidBST_recur(root, Integer.MIN_VALUE-1L, Integer.MAX_VALUE+1L);\n}\n\npublic static boolean isValidBST_recur(TreeNode curr, long min, long max){\n    if (curr==null) return true;\n    if (curr.val&lt;=min || curr.val&gt;=max) return false;\n    return isValidBST_recur(curr.left, (long)min, curr.val) &amp;&amp; isValidBST_recur(curr.right, curr.val, (long)max);\n}\n</code></pre><code>public boolean isValidBST(TreeNode root) {\n    return isValidBST_recur(root, Integer.MIN_VALUE-1L, Integer.MAX_VALUE+1L) &amp;&amp; isValidBST_recur(root, Integer.MIN_VALUE-1L, Integer.MAX_VALUE+1L);\n}\n\npublic static boolean isValidBST_recur(TreeNode curr, long min, long max){\n    if (curr==null) return true;\n    if (curr.val&lt;=min || curr.val&gt;=max) return false;\n    return isValidBST_recur(curr.left, (long)min, curr.val) &amp;&amp; isValidBST_recur(curr.right, curr.val, (long)max);\n}\n</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "cbmbbz", "catagory": "Validate Binary Search Tree", "author_score": "17,220", "time": "2014-12-10T08:05:24+0000"}, "comments": [{"content": "<p>Good catch!!</p>", "votes": null, "meta": {"author": "AndrewJiang", "author_score": "100", "time": "2015-03-28T16:28:01+0000"}}]}, "answers": [], "title": "accepted recursive Java solution, very concise"}, {"question": {"content": "<p>it is DFS so u need a stack. Dont forget to set the left child to null, or u'll get TLE. (tricky!)</p><pre><code>   public void flatten(TreeNode root) {\n        if (root == null) return;\n        Stack&lt;TreeNode&gt; stk = new Stack&lt;TreeNode&gt;();\n        stk.push(root);\n        while (!stk.isEmpty()){\n            TreeNode curr = stk.pop();\n            if (curr.right!=null)  \n                 stk.push(curr.right);\n            if (curr.left!=null)  \n                 stk.push(curr.left);\n            if (!stk.isEmpty()) \n                 curr.right = stk.peek();\n            curr.left = null;  // dont forget this!! \n        }\n    }\n</code></pre><code>   public void flatten(TreeNode root) {\n        if (root == null) return;\n        Stack&lt;TreeNode&gt; stk = new Stack&lt;TreeNode&gt;();\n        stk.push(root);\n        while (!stk.isEmpty()){\n            TreeNode curr = stk.pop();\n            if (curr.right!=null)  \n                 stk.push(curr.right);\n            if (curr.left!=null)  \n                 stk.push(curr.left);\n            if (!stk.isEmpty()) \n                 curr.right = stk.peek();\n            curr.left = null;  // dont forget this!! \n        }\n    }\n</code>", "votes": {"down": "2", "up": "17"}, "meta": {"author": "cbmbbz", "catagory": "Flatten Binary Tree to Linked List", "author_score": "17,220", "time": "2014-12-07T05:51:45+0000"}, "comments": [{"content": "<p>\uff01I like  your answer  very much.Thanks, after trying many times</p>", "votes": null, "meta": {"author": "namedfree", "author_score": "150", "time": "2015-01-15T11:58:42+0000"}}, {"content": "<p>Not an in-place solution.</p>", "votes": null, "meta": {"author": "siyang3", "author_score": "11,210", "time": "2015-01-18T23:25:17+0000"}}]}, "answers": [{"content": "<p>thank you for the</p><blockquote>\n  <p>Dont forget to set the left child to null, or u'll get TLE. (tricky!)</p>\n</blockquote><p>Dont forget to set the left child to null, or u'll get TLE. (tricky!)</p><p>:) .\nAnd i don't think your answer is a in-place algorithm,because of the using of stack .</p>", "votes": {"down": "2", "up": "3"}, "meta": {"author": "Casin", "author_score": "250", "time": "2014-12-11T05:14:44+0000"}, "comments": [{"content": "<p>Using a stack doesn't make it not in-place, in-place means direct change to the original given data. Think about sorting an array, an in-place sort will sort the array without explicit return while a not-in-place sort would return a sorted array and keep the original input array intact. </p>", "votes": null, "meta": {"author": "fei17", "author_score": "210", "time": "2015-01-09T17:11:30+0000"}}, {"content": "<p>But the algorithm does not use the constant extra space because of the using of stack...\nI search the In-Place algorithm in wiki,and the following is the link of it.\nhttp://en.wikipedia.org/wiki/In-place_algorithm</p>", "votes": null, "meta": {"author": "Casin", "author_score": "250", "time": "2015-01-10T01:07:32+0000"}}, {"content": "<p>You are right, my understanding of in-place was not fully correct, thank you for the link!</p>", "votes": null, "meta": {"author": "fei17", "author_score": "210", "time": "2015-01-10T03:13:43+0000"}}, {"content": "<p>thanks for your link</p>", "votes": null, "meta": {"author": "aholic", "author_score": "160", "time": "2015-02-13T09:07:06+0000"}}]}], "title": "accepted simple Java solution , iterative"}, {"question": {"content": "<p>for explanation plz see comments in the code </p><pre><code>public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] num) {\n    Arrays.sort(num);\n    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    int len = num.length;\n    if (len == 0) return ans; \n\n    ans.add(new ArrayList&lt;Integer&gt;()); // first, need to add the subset of num[0]\n    ans.add(new ArrayList&lt;Integer&gt;());\n    ans.get(1).add(num[0]);\n\n    int nprev = 1; // this is the number of lists that the previous number was added in.\n                 // if the current number is same as the prev one, it'll be only added in the \n                // lists that has the prev number.\n\n    for (int i = 1; i &lt; len ; ++i){\n        int size = ans.size();\n        if (num[i]!=num[i-1])   // if different\n            nprev = size;        // this means add num[i] to all lists in ans;\n        for (int j = size-nprev; j &lt; size; ++j){\n            List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;(ans.get(j));\n            l.add(num[i]);\n            ans.add(l);\n        }\n    }\n    return ans;\n}\n</code></pre><code>public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] num) {\n    Arrays.sort(num);\n    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    int len = num.length;\n    if (len == 0) return ans; \n\n    ans.add(new ArrayList&lt;Integer&gt;()); // first, need to add the subset of num[0]\n    ans.add(new ArrayList&lt;Integer&gt;());\n    ans.get(1).add(num[0]);\n\n    int nprev = 1; // this is the number of lists that the previous number was added in.\n                 // if the current number is same as the prev one, it'll be only added in the \n                // lists that has the prev number.\n\n    for (int i = 1; i &lt; len ; ++i){\n        int size = ans.size();\n        if (num[i]!=num[i-1])   // if different\n            nprev = size;        // this means add num[i] to all lists in ans;\n        for (int j = size-nprev; j &lt; size; ++j){\n            List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;(ans.get(j));\n            l.add(num[i]);\n            ans.add(l);\n        }\n    }\n    return ans;\n}\n</code>", "votes": {"down": "0", "up": "5"}, "meta": {"author": "cbmbbz", "catagory": "Subsets II", "author_score": "17,220", "time": "2014-12-06T02:14:55+0000"}}, "answers": [], "title": "accepted java iterative solution"}, {"question": {"content": "<p>The iterative way to do it is to use a stack, since preorder is basically dfs. Just remember to push the right child and then the left child, which makes the left one come out first.</p><p>The recursive solution is more concise though.  here i present both ways to solve this problem.</p><pre><code>   public class Solution {\n    //first is iterative solution\n        public List&lt;Integer&gt; preorderTraversal(TreeNode root) {\n            List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();\n            if (root==null) return ans;\n            Stack&lt;TreeNode&gt; st = new Stack&lt;TreeNode&gt;();\n            st.push(root);\n            while (!st.isEmpty()){\n                TreeNode curr = st.pop();\n                ans.add(curr.val);\n                if (curr.right!=null) st.push(curr.right);\n                if (curr.left!=null) st.push(curr.left);\n            }\n\n            return ans;\n        }\n\n\n    //then recursive\n        public List&lt;Integer&gt; preorderTraversal_recur(TreeNode root) {\n            List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();\n            if (root==null) return ans;\n            ans.add(root.val);\n            ans.addAll(preorderTraversal_recur(root.left));\n            ans.addAll(preorderTraversal_recur(root.right));\n            return ans;\n        }\n    }\n</code></pre><code>   public class Solution {\n    //first is iterative solution\n        public List&lt;Integer&gt; preorderTraversal(TreeNode root) {\n            List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();\n            if (root==null) return ans;\n            Stack&lt;TreeNode&gt; st = new Stack&lt;TreeNode&gt;();\n            st.push(root);\n            while (!st.isEmpty()){\n                TreeNode curr = st.pop();\n                ans.add(curr.val);\n                if (curr.right!=null) st.push(curr.right);\n                if (curr.left!=null) st.push(curr.left);\n            }\n\n            return ans;\n        }\n\n\n    //then recursive\n        public List&lt;Integer&gt; preorderTraversal_recur(TreeNode root) {\n            List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();\n            if (root==null) return ans;\n            ans.add(root.val);\n            ans.addAll(preorderTraversal_recur(root.left));\n            ans.addAll(preorderTraversal_recur(root.right));\n            return ans;\n        }\n    }\n</code>", "votes": {"down": "0", "up": "1"}, "meta": {"author": "cbmbbz", "catagory": "Binary Tree Preorder Traversal", "author_score": "17,220", "time": "2014-12-03T05:59:52+0000"}}, "answers": [], "title": "Accepted Java iterative and recursive solutions"}, {"question": {"content": "<p>The basic idea is when elem is found at index i, let A[i] = the last element in the modifying array, then repeat searching until elem is not found.</p><pre><code>public int removeElement(int[] A, int elem) {\n    int len = A.length;\n    for (int i = 0 ; i&lt; len; ++i){\n        while (A[i]==elem &amp;&amp; i&lt; len) {\n            A[i]=A[--len];\n        }\n    }\n    return len;\n}\n</code></pre><code>public int removeElement(int[] A, int elem) {\n    int len = A.length;\n    for (int i = 0 ; i&lt; len; ++i){\n        while (A[i]==elem &amp;&amp; i&lt; len) {\n            A[i]=A[--len];\n        }\n    }\n    return len;\n}\n</code>", "votes": {"down": "2", "up": "22"}, "meta": {"author": "cbmbbz", "catagory": "Remove Element", "author_score": "17,220", "time": "2014-11-17T01:22:58+0000"}}, "answers": [{"content": "<p>what if the last element also equals to elem?</p>", "votes": {"down": "1", "up": "1"}, "meta": {"author": "wenjunw", "author_score": "180", "time": "2014-11-29T19:30:06+0000"}, "comments": [{"content": "<p>the loop inside is a while loop which will deal with the case that the last element equals to elem.</p>", "votes": null, "meta": {"author": "peng22", "author_score": "110", "time": "2014-12-10T15:03:52+0000"}}]}], "title": "9-line java solution"}, {"question": {"content": "<p>this problem was discussed by Jon Bentley (Sep. 1984 Vol. 27 No. 9 Communications of the ACM P885)</p><p>the paragraph below was copied from his paper (with a little modifications)</p><p>algorithm that operates on arrays: it starts at the left end (element A[1]) and scans through to the right end (element A[n]), keeping track of the maximum sum subvector seen so far. The maximum is initially A[0]. Suppose we've solved the problem for A[1 .. i - 1]; how can we extend that to A[1 .. i]? The maximum \nsum in the first I elements is either the maximum sum in the first i - 1 elements (which we'll call MaxSoFar), or it is that of a subvector that ends in position i (which we'll call MaxEndingHere).  </p><p>MaxEndingHere is either A[i] plus the previous MaxEndingHere, or just A[i], whichever is larger.</p><pre><code>public static int maxSubArray(int[] A) {\n    int maxSoFar=A[0], maxEndingHere=A[0];\n    for (int i=1;i&lt;A.length;++i){\n        maxEndingHere= Math.max(maxEndingHere+A[i],A[i]);\n        maxSoFar=Math.max(maxSoFar, maxEndingHere); \n    }\n    return maxSoFar;\n}\n</code></pre><code>public static int maxSubArray(int[] A) {\n    int maxSoFar=A[0], maxEndingHere=A[0];\n    for (int i=1;i&lt;A.length;++i){\n        maxEndingHere= Math.max(maxEndingHere+A[i],A[i]);\n        maxSoFar=Math.max(maxSoFar, maxEndingHere); \n    }\n    return maxSoFar;\n}\n</code>", "votes": {"down": "0", "up": "55"}, "meta": {"author": "cbmbbz", "catagory": "Maximum Subarray", "author_score": "17,220", "time": "2014-11-11T05:32:22+0000"}, "comments": [{"content": "<p>Kadane's algorithm</p>", "votes": null, "meta": {"author": "kg21mn", "author_score": "320", "time": "2015-04-22T07:01:28+0000"}}, {"content": "<p>Even masters in computer science solved LeetCode problems in the past :-)</p>", "votes": null, "meta": {"author": "jianchao.li.fighter", "author_score": "53,420", "time": "2015-08-16T07:26:55+0000"}}, {"content": "<p>Best and most clear approach that you can ever get. If still in doubt, check this video tutorial on Kaden's algorithm.\nhttps://www.youtube.com/watch?v=epTQfFlhQBo</p>", "votes": null, "meta": {"author": "san89kalp", "author_score": "980", "time": "2015-09-09T07:48:40+0000"}}]}, "answers": [{"content": "<p>Similar idea, reset if left sum is a negative value.</p><pre><code>class Solution {\npublic:\n    int maxSubArray(int A[], int n) {\n        int maxSub = INT_MIN;\n        int leftPositive = 0;\n        for (int i = 0; i &lt; n; i++) {\n            maxSub = max(maxSub, leftPositive + A[i]);\n            leftPositive = max(0, leftPositive + A[i]);\n        }\n        return maxSub;\n    }\n};\n</code></pre><code>class Solution {\npublic:\n    int maxSubArray(int A[], int n) {\n        int maxSub = INT_MIN;\n        int leftPositive = 0;\n        for (int i = 0; i &lt; n; i++) {\n            maxSub = max(maxSub, leftPositive + A[i]);\n            leftPositive = max(0, leftPositive + A[i]);\n        }\n        return maxSub;\n    }\n};\n</code>", "votes": {"down": "0", "up": "2"}, "meta": {"author": "flyflybird", "author_score": "1,330", "time": "2014-12-24T07:16:34+0000"}, "comments": [{"content": "<p>Hi, flyflybird. I happen to have a similar code :-)</p><pre><code>class Solution { \npublic:\n    int maxSubArray(vector&lt;int&gt;&amp; nums) {\n        int sum = 0, smax = INT_MIN;\n        for (int num : nums) {\n            sum += num;\n            if (sum &gt; smax) smax = sum;\n            if (sum &lt; 0) sum = 0;\n        }\n        return smax;\n    }\n};\n</code></pre><code>class Solution { \npublic:\n    int maxSubArray(vector&lt;int&gt;&amp; nums) {\n        int sum = 0, smax = INT_MIN;\n        for (int num : nums) {\n            sum += num;\n            if (sum &gt; smax) smax = sum;\n            if (sum &lt; 0) sum = 0;\n        }\n        return smax;\n    }\n};\n</code>", "votes": null, "meta": {"author": "jianchao.li.fighter", "author_score": "53,420", "time": "2015-08-16T07:26:00+0000"}}]}, {"content": "<p>Thanks for the explanation, good idea.</p><p>I think we should also consider   <code>if (nums == null || nums.length == 0);</code> </p><code>if (nums == null || nums.length == 0);</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "lizhu5058", "author_score": "250", "time": "2015-09-10T04:17:03+0000"}}], "title": "accepted O(n) solution in java"}, {"question": {"content": "<p>the basic idea is to recursively find the correct path, and when it hits the leaf (base case) then add a new List to the output 2D list, then when it goes back to the previous recursion, add the node value to all the List in the output 2D list.</p><pre><code>public static List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {\n    List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    if(root==null) return list;\n    if (root.val==sum &amp;&amp; root.left==null &amp;&amp; root.right==null)   {\n        list.add(new ArrayList&lt;Integer&gt;());\n        list.get(list.size()-1).add(root.val);\n        return list;\n    }\n    list.addAll(pathSum(root.left, sum-root.val));\n    list.addAll(pathSum(root.right, sum-root.val));\n    for(List&lt;Integer&gt; l:list)\n        l.add(0, root.val);\n    return list;\n}\n</code></pre><code>public static List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {\n    List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    if(root==null) return list;\n    if (root.val==sum &amp;&amp; root.left==null &amp;&amp; root.right==null)   {\n        list.add(new ArrayList&lt;Integer&gt;());\n        list.get(list.size()-1).add(root.val);\n        return list;\n    }\n    list.addAll(pathSum(root.left, sum-root.val));\n    list.addAll(pathSum(root.right, sum-root.val));\n    for(List&lt;Integer&gt; l:list)\n        l.add(0, root.val);\n    return list;\n}\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "cbmbbz", "catagory": "Path Sum II", "author_score": "17,220", "time": "2014-11-05T02:13:25+0000"}}, "answers": [{"content": "<p>the following hacks don't look very good, maybe you can improve it.</p><p><code>list.get(list.size()-1).add(root.val);</code> and <code>for(List&lt;Integer&gt; l:list) l.add(0, root.val);</code> </p><code>list.get(list.size()-1).add(root.val);</code><code>for(List&lt;Integer&gt; l:list) l.add(0, root.val);</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "koven", "author_score": "770", "time": "2014-11-05T16:51:59+0000"}, "comments": [{"content": "<p>How to improve? Thanks!</p>", "votes": null, "meta": {"author": "EthanLi", "author_score": "10", "time": "2015-01-28T02:33:25+0000"}}]}], "title": "14-line solution in java using recursion"}, {"question": {"content": "<pre><code>public static List&lt;List&lt;Integer&gt;&gt; generate(int numRows) {\n    List&lt;List&lt;Integer&gt;&gt; l = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    if (numRows ==0) return l;\n    l.add(new ArrayList&lt;Integer&gt;());\n    l.get(0).add(1);\n    if (numRows ==1) return l;\n    for (int i = 1;i&lt;numRows;++i){\n        l.add(new ArrayList&lt;Integer&gt;());\n        l.get(i).add(1);\n        for (int j = 1; j&lt;i;++j){\n            l.get(i).add(l.get(i-1).get(j-1)+l.get(i-1).get(j));\n        }\n        l.get(i).add(1);\n    }\n    return l;\n}\n</code></pre><code>public static List&lt;List&lt;Integer&gt;&gt; generate(int numRows) {\n    List&lt;List&lt;Integer&gt;&gt; l = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    if (numRows ==0) return l;\n    l.add(new ArrayList&lt;Integer&gt;());\n    l.get(0).add(1);\n    if (numRows ==1) return l;\n    for (int i = 1;i&lt;numRows;++i){\n        l.add(new ArrayList&lt;Integer&gt;());\n        l.get(i).add(1);\n        for (int j = 1; j&lt;i;++j){\n            l.get(i).add(l.get(i-1).get(j-1)+l.get(i-1).get(j));\n        }\n        l.get(i).add(1);\n    }\n    return l;\n}\n</code>", "votes": {"down": "1", "up": "1"}, "meta": {"author": "cbmbbz", "catagory": "Pascal's Triangle", "author_score": "17,220", "time": "2014-11-03T06:46:24+0000"}, "comments": [{"content": "<p>Thanks, very smart way</p>", "votes": null, "meta": {"author": "vansonlin", "author_score": "580", "time": "2014-11-07T02:43:33+0000"}}]}, "answers": [], "title": "my accepted java solution, 16 lines"}, {"question": {"content": "<pre><code>public class Solution {\npublic static boolean isPalindrome(String s) {\n    if(s==\"\"||s.length()==1) return true;\n    char[] c = s.toCharArray();\n    for (int i = 0, j = c.length-1; i&lt;j; ++i,--j){\n        while (!Character.isLetterOrDigit(c[i]))\n            if (i&lt;j) ++i;\n            else break;\n        while (!Character.isLetterOrDigit(c[j]))\n            if (i&lt;j) --j;\n            else break;\n        if (c[i]!=c[j]&amp;&amp;'a'-'A'!=(int)Math.abs(c[i]-c[j])) \n            return false;\n    }\n    return true;\n}\n</code></pre><code>public class Solution {\npublic static boolean isPalindrome(String s) {\n    if(s==\"\"||s.length()==1) return true;\n    char[] c = s.toCharArray();\n    for (int i = 0, j = c.length-1; i&lt;j; ++i,--j){\n        while (!Character.isLetterOrDigit(c[i]))\n            if (i&lt;j) ++i;\n            else break;\n        while (!Character.isLetterOrDigit(c[j]))\n            if (i&lt;j) --j;\n            else break;\n        if (c[i]!=c[j]&amp;&amp;'a'-'A'!=(int)Math.abs(c[i]-c[j])) \n            return false;\n    }\n    return true;\n}\n</code><p>}</p>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "cbmbbz", "catagory": "Valid Palindrome", "author_score": "17,220", "time": "2014-11-02T21:40:33+0000"}}, "answers": [], "title": "my java solution in one pass"}, {"question": {"content": "<pre><code>public class Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return check (root, root);\n    }\n    public boolean check(TreeNode p , TreeNode q){\n        if (p==null&amp;&amp;q==null) return true;\n        if (p==null^q==null || p.val != q.val) return false;\n        return check(p.left,q.right)&amp;&amp;check(p.right,q.left);\n    }\n}\n</code></pre><code>public class Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return check (root, root);\n    }\n    public boolean check(TreeNode p , TreeNode q){\n        if (p==null&amp;&amp;q==null) return true;\n        if (p==null^q==null || p.val != q.val) return false;\n        return check(p.left,q.right)&amp;&amp;check(p.right,q.left);\n    }\n}\n</code>", "votes": {"down": "1", "up": "3"}, "meta": {"author": "cbmbbz", "catagory": "Symmetric Tree", "author_score": "17,220", "time": "2014-11-01T00:14:04+0000"}, "comments": [{"content": "<p>Mine was very similar, however it should be noted that your solution checks the entire tree twice due to the check(root, root) call. This recurses on root.left, root.right in the first check, then root.right, root.left on the second check which is redundant and results in an extra traversal of the tree. The following eliminates the redundant check. </p><pre><code>bool isSymmetric(TreeNode *root) {\n    if (root == NULL) return true;\n    return isSymmetric(root-&gt;left, root-&gt;right);\n}\n\nbool isSymmetric(TreeNode *left, TreeNode *right) {\n    if (left == NULL &amp;&amp; right == NULL) return true;\n    if (left == NULL || right == NULL) return false;\n    return left-&gt;val == right-&gt;val &amp;&amp; isSymmetric(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetric(left-&gt;right, right-&gt;left);\n}\n</code></pre><code>bool isSymmetric(TreeNode *root) {\n    if (root == NULL) return true;\n    return isSymmetric(root-&gt;left, root-&gt;right);\n}\n\nbool isSymmetric(TreeNode *left, TreeNode *right) {\n    if (left == NULL &amp;&amp; right == NULL) return true;\n    if (left == NULL || right == NULL) return false;\n    return left-&gt;val == right-&gt;val &amp;&amp; isSymmetric(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetric(left-&gt;right, right-&gt;left);\n}\n</code>", "votes": null, "meta": {"author": "greatgrahambini", "author_score": "790", "time": "2014-11-18T23:34:38+0000"}}, {"content": "<pre><code>public boolean isSymmetric(TreeNode root) {\n    return isSymmetric(root, root);\n}\n\nprivate boolean isSymmetric(TreeNode node1, TreeNode node2) {\n    if (node1 == null || node2 == null) return node1 == null &amp;&amp; node2 == null;\n    return node1.val == node2.val&amp;&amp;isSymmetric(node1.left, node2.right) &amp;&amp; isSymmetric(node1.right, node2.left);\n}\n</code></pre><code>public boolean isSymmetric(TreeNode root) {\n    return isSymmetric(root, root);\n}\n\nprivate boolean isSymmetric(TreeNode node1, TreeNode node2) {\n    if (node1 == null || node2 == null) return node1 == null &amp;&amp; node2 == null;\n    return node1.val == node2.val&amp;&amp;isSymmetric(node1.left, node2.right) &amp;&amp; isSymmetric(node1.right, node2.left);\n}\n</code>", "votes": null, "meta": {"author": "peterdyf", "author_score": "2,410", "time": "2014-12-12T06:33:15+0000"}}]}, "answers": [], "title": "10-line solution with recursion in Java"}, {"question": {"content": "<pre><code>   public static String countAndSay(int n) {\n                String s = \"\";\n        if (n==1) return \"1\";\n        String prev = countAndSay(n-1);\n        int ct;\n        char [] c = prev.toCharArray();\n        for (int i = 0; i&lt;c.length; ++i ){\n            ct = 1;\n            for (;i&lt;c.length-1 &amp;&amp; c[i]==c[i+1];) {\n                ct++;\n                i++;  \n            }\n            s+=ct+\"\"+c[i];\n        }\n        return s;\n    }\n</code></pre><code>   public static String countAndSay(int n) {\n                String s = \"\";\n        if (n==1) return \"1\";\n        String prev = countAndSay(n-1);\n        int ct;\n        char [] c = prev.toCharArray();\n        for (int i = 0; i&lt;c.length; ++i ){\n            ct = 1;\n            for (;i&lt;c.length-1 &amp;&amp; c[i]==c[i+1];) {\n                ct++;\n                i++;  \n            }\n            s+=ct+\"\"+c[i];\n        }\n        return s;\n    }\n</code>", "votes": {"down": "0", "up": "0"}, "meta": {"author": "cbmbbz", "catagory": "Count and Say", "author_score": "17,220", "time": "2014-10-31T20:29:04+0000"}}, "answers": [], "title": "14-line solution using recursion in java"}], "UserInfo": {"voted_answer": "6", "score": "17,220", "got_upvote": "341", "comments": "5", "questions": "24", "voted_question": "18", "got_downvote": "10", "give_downvote": "0", "give_upvote": "24", "answers": "3"}}]